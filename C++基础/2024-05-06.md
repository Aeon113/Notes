# TCP TIME_WAIT

TIME_WAIT是TCP连接关闭过程中的一个状态，具体是这么形成的：
1 主动关闭端A：发FIN，进入FIN-WAIT-1状态，并等待......
2 被动关闭端P：收到FIN后必须立即发ACK，进入CLOSE_WAIT状态，并等待......
3 主动关闭端A：收到ACK后进入FIN-WAIT-2状态，并等待......
4 被动关闭端P：发FIN，进入LAST_ACK状态，并等待......
5 主动关闭端A：收到FIN后必须立即发ACK，进入TIME_WAIT状态，等待2MSL后结束Socket
6 被动关闭端P：收到ACK后结束Socket

因此，TIME_WAIT状态是出现在主动发起连接关闭的一点，和是谁发起的连接无关，可以是client端，也可以是server端。
而从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s, 也就是说Linux中TIME_WAIT状态默认持续60s）

为什么需要TIME_WAIT？
主要有两个原因：
1）为了确保两端能完全关闭连接。
假设A服务器是主动关闭连接方，B服务器是被动方。如果没有TIME_WAIT状态，A服务器发出最后一个ACK就进入关闭状态，如果这个ACK对端没有收到，对端就不能完成关闭。对端没有收到ACK，会重发FIN，此时连接关闭，这个FIN也得不到ACK，而有TIME_WAIT，则会重发这个ACK，确保对端能正常关闭连接。
2）为了确保后续的连接不会收到“脏数据”
刚才提到主动端进入TIME_WAIT后，等待2MSL后CLOSE，这里的MSL是指（maximum segment lifetime，我们内核一般是30s，2MSL就是1分钟），网络上数据包最大的生命周期。这是为了使网络上由于重传出现的old duplicate segment都消失后，才能创建参数（四元组，源IP/PORT，目标IP/PORT）相同的连接，如果等待时间不够长，又创建好了一样的连接，再收到old duplicate segment，数据就错乱了。

# TCP CLOSE_WAIT
CLOSE_WAIT是被动关闭连接是形成的，根据TCP状态机，服务器端收到客户端发送的FIN，TCP协议栈会自动发送ACK，连接进入CLOSE_WAIT状态。但如果服务器端不执行SOCKET的CLOSE()操作，状态就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接.

所以如果被动关闭端关闭SOCKET不及时, 例如: I/O线程被意外阻塞，或者I/O线程执行的用户自定义Task比例过高，导致I/O操作处理不及时，链路不能被及时释放.

通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下可能：

(1) 程序问题：如果代码层面忘记了 CLOSE 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 CLOSE 也永远执行不到。

(2) 响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。

# PFC 和 ECN
## PFC
PFC 是构建无损以太网的必选手段之一， 能够逐跳提供基于优先级的流量控制。 设备在进行报文转发时，根据报文的优先级进入对应映射关系的队列中进行调度转发。 当某一优先级报文发送速率超过接收速率，导致接收方可用数据缓冲空间不足时， 设备通过PFC PAUSE 帧反馈给上一跳设备，上一跳设备收到 PAUSE 帧报文后停止发送本优先级报文，直到再收到PFC XON帧或经过一定的老化时间后才能恢复流量发送。通过使用 PFC功能，使得某种类型的流量拥塞不会影响其他类型流量的正常转发，从而达到同一链路上不同类型的报文互不影响。

## ECN
ECN是构建无损以太网的必选手段之一。 ECN定义了一种基于IP层及传输层的流量控制及端到端拥塞通知机制。 ECN功能利用IP报文头中的DS域来标记报文传输路径上的拥塞状态。 支持该功能的终端设备可以通过报文内容判断出传输路径上发生了拥塞，从而调整报文的发送方式，避免拥塞加剧。

# STL 迭代器失效:

## vector:
若向容器插入元素后, 新的`size()`大于原`capacity()`, 则会引发扩容, 所有迭代器均失效。

若向容器插入元素后, 新的`size()`小于等于原`capacity()`, 则不会引发扩容, 指向被插入元素前方的迭代器均有效, 指向被插入元素后方的迭代器均失效。

若从容器删除元素, 则指向被删除元素或其后方元素的迭代器均失效。



## deque:
若向容器首部或尾部插入元素, 则所有已有迭代器均有效; 若向中间插入元素, 则所有迭代器均失效。

若从容器首部或尾部删除元素, 则所有指向被删除元素以外的迭代器均有效; 若从中间删除元素, 则所有迭代器均失效


## list, set, unordered_set, unordered_map

若向容器插入元素, 则所有已有迭代器均有效。

若从容器删除元素, 则指向除了被删元素以外的其它元素的迭代器均有效。