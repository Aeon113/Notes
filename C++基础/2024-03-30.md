# 2024-03-30

## 1. 进程和线程的区别

进程是资源分配的基本单位，线程是cpu调度的基本单位。

一个进程可以包含有多个线程。

进程间切换的效率要低于线程间切换。

业务采用多进程，健壮性要强于多线程的模式。

## 2. 系统调用是否会引起线程切换

有可能

## 3. TCP和UDP的区别

1. TCP是面向连接的, 它需要建链、断链操作，它的数据传输是点对点的。而UDP则无需建链和断链，它可以一对多或多对一的发送数据。
2. TCP的应用层接收和发送的是字节流，UDP收发的是报文。
3. TCP是可靠传输，UDP不是可靠传输。TCP利用序列号，滑动窗口，拥塞控制，重传机制等来保证可靠传输，而UDP不会确认数据是否被成功接收，也没用重传等机制和拥塞控制，也不保证接收顺序。
4. TCP的传输效率低，而UDP的传输效率高。因为可靠传输需要牺牲传输效率；另外TCP的协议头要大于UDP，因此发送同样量的数据，TCP需要更大的流量。
5. 通常TCP被用在对可靠性要求高的场景，UDP用在对实时性要求高的场景。

## 4. 其它TCP相关

1. 为什么TCP需要序列号: 因为应用层收发的是字节流，而字节流需要保序。数据在网络传输的过程中，可能出现报文拆分和丢包；接收端收到数据的顺序也可能不同于发送端的发送顺序。同时发送端也可能进行重传的行为。而且TCP的可靠传输还需要接收端返回ack序列号标记来进行确认应答。
2. 为什么每次TCP建链都需要随机选取序列号: 防止两端之间的历史连接上的数据包影响本连接。
3. 滑动窗口机制的目的: 流量控制，通过增加或减少滑动窗口的大小来增加或减少发送流量；保证可靠传输，通过发送窗口，和接收方返回的ack序列号，发送方可以确认哪些数据已被对端成功接收，哪些数据需要重新发送。

## 5. TCP如何保证可靠性

依赖重传机制，滑动窗口，流量控制和拥塞控制。

1. 重传机制：首先，TCP依赖序列号和序列应答来判断对端是否成功收到了数据。然后，触发重传的方式主要有2种，一种是超时重传，如果一段时间内没有收到来自对端的相应的ack信息，则开始重传；另一种是快重传，如果在超时定时器触发前，收到了对端的3次相同的ack序列号，则从此ack对应的字节开始重传。

> 一种TCP的拓展是SACK。当接收端收到一个乱序的数据包时，它会在ACK包的选项字段中添加一个SACK选项，这个选项包含了接收端已经接收到的非连续数据段的起始和结束序列号。这样，发送端就可以知道哪些数据包已经被接收，哪些数据包需要重传。
>
> DSACK: 这是一种在SACK基础上的拓展。当接收端收到一个重复的数据包时，它会在ACK包的选项字段中添加一个DSACK选项，这个选项包含了接收端收到的重复数据段的起始和结束序列号。这样，发送端就可以知道哪些数据包被错误地重传了。
>

2. 滑动窗口: 决定了在未收到应答的情况下，发送方可以发送多少数据。

> 窗口通常在三次握手时就决定了初始值。通常两端各有一个接收滑动窗口和一个发送滑动窗口。

3. 流量控制: 接收方通过控制接收的数据量，来限制发送方的数据发送量，避免产生丢包。具体方法是先收缩接收滑动窗口，再减少接收缓冲区。
4. 拥塞控制: 慢启动等，具体有多种不同的拥塞控制算法。·

## 6. `malloc()`是如何分配内存的
1. 当需求的内存大小小于128K时，通过mmap在文件映射区创建一个private, anonymous内存来分配；如果需求的内存小于128K，则先从内部内存池分配；如果内存池中分配不出目标内存，则通过brk系统调用扩展堆区，并扩展内部内存池，然后再分配。
2. 这里分配出来的都是虚拟内存
3. `malloc()`不是系统调用

## 6. 左指引用和右值引用的区别

左值引用就是对左值的引用，右值引用是对右值的引用。

扩展:

1. 使用左值引用，主要是为了避免和左值的拷贝。
2. 使用右值引用，主要是为了引入移动语意和完美转发。
3. 可以放在等号左边的值就是左值，它通常可以通过`&`符号取地址，而且它大概率是有名字的。
4. 只能放在等号右边的值是右值，右值不能通过`&`符号取地址，而且它也没有名字。
5. 右值分为2类，纯右值(prvalue)和将亡值(xvalue)。
6. prvalue包括字面值(比如`10`, `"hello"`)，返回值类型不是引用类型的函数调用(比如 `open("file", "r+")`)和后置自增/自减，以及逻辑/算术表达式(比如`a+b`, `3 < 2`)。
7. xvalue，或者称为"将亡值"，是一种特殊的右值。它们是对象的某种状态，这种状态表示对象即将被销毁，可以安全地移动其资源。xvalue的主要来源包括：返回值类型是右值引用的函数调用、std::move的返回值、转换函数，如static_cast<T&&>()、一些标准库函数，如std::forward。这些都是xvalue的例子，它们通常不具有名称，但是它们的资源可以被另一个对象安全地重用。这是C++11引入右值引用和移动语义的主要原因，以优化性能，避免不必要的拷贝。

## 7. 左值引用是否只能指向左值，右值引用是否只能指向右值

左值引用也可以指向右值，但必须是const引用(形似`const T &`)，因为不能允许通过左值引用修改被指向的右值。因此需要引入右值引用，因为可以通过右值引用修改右值。

右值引用，也可以指向左值，只要使用`std::move`移动左值即可。

左值引用和右值引用，它们本身都是左值。

移动语意: 是一种避免资源重复拷贝造成浪费的一种机制。它通过移动构造和移动赋值来实现。

## 8. 什么是完美转发

这个功能被用在函数模板中。因为对左值的引用和对右值的引用都是左值，所以函数模板的参数不管是左值引用还是右值引用，这个形参在函数模板内部都会被以左值的形式使用。而完美转发则可以还原被引用指向的值本身的左值或右值属性。

依据引用折叠语法，函数模板也需要以 `T && t`的形式来接受需要完美转发的函数。然后，再将`T`以模板参数的形式，将`t`以普通参数的形式，传给`std::forward`，此时就可以实现完美转发。

```c++
template <T>
void foo(T && t) {
    v.emplace_back(std::forward<T>(t));
}
```

## 9. 智能指针相关
需要考虑以下问题:

1. 智能指针解决了裸指针的什么问题，怎么解决的
> 1. 内存泄漏问题
> 2. use after free问题
> 3. double free问题
>
> 怎么解决的: 使用RAII思想，将指针指向的资源的生命周期和指向它的智能指针对象的声明周期绑定，使得在特定条件满足时，智能指针对象析构时能够一并回收掉相应的资源。
2. 有哪些智能指针(`unique_ptr`, `shared_ptr`, `weak_ptr`, `auto_ptr 已废弃`)
3. `weak_ptr`是怎么解决循环引用问题的。

