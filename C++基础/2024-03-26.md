# 1.

申请内存(malloc)时，如果堆的扩充大小小于128K, 就使用brk (break)，否则则是mmap。Brk扩张的是堆区（heap区），mmap扩张的是文件映射区。

对于堆上内存(heap区)，glibc会创建内存池管理。

free()的内存，如果处于heap区中，则目标内存会被放回内存池；如果是mmap出来的，则会立刻被munmap掉。

# 2.

静态多态: 函数重载，运算符重载，模板(模板算不算要讨论)

动态多态: 虚函数，std::visit+std::variant(std::visit算不算要讨论)

## 虚函数表

1. 虚函数表在编译时生成(检测到继承链上的某个class拥有virtual修饰的成员函数时就生成)，其存放在.rodata段中。
2. 构造函数中调用虚函数时是没有多态效果的。构造函数调用完成后才会设置vptr。在对象构造过程中，先将vptr指向基类的vtable, 调用基类构造函数，再指向派生类vtable，再调用派生类构造函数。

# 3. ELF的几个主要组成段

1. `.bss` 存放未初始化的或需要初始化为0的全局或静态变量，其在实际执行时，在内存中需要填全0；所以事实上它在程序文件中不占任何空间
2. `.data` 存放需要初始化为非0值的全局或静态变量
3. `.rodata` 存放只读数据，这里面的数据在程序运行期间不变化。虚函数表就放在这里面。
4. `.text` 存放代码

-----

这里在2介绍下x86-64的进程各段(由低地址到高地址):

1. 代码段
2. 已初始化数据
3. 未初始化数据
4. 堆 (大小可增长，由低地址向高地址增长)
5. 文件映射段 (动态库，文件映射等)
6. 栈 
7. 内存空间

# 4. 进程内存布局

(地址由高到低)

内核空间

栈区

文件映射区

堆区

数据区 (.bss .data)

代码区 (.rodata .text)

# 5. 什么情况会触发拷贝构造函数

```C++
A b;
A a(b); // 这里会触发

A c = b; // 这里也会触发

// 函数按值传参时会触发
// 函数返回值时，如果不满足rvo条件，且也没有移动构造函数，则也会触发
```

# 6. 什么时候编译器会给一个class自动生成成员函数

如果没有用户声明的构造函数，则会自动生成默认构造函数（§12.1/5）。

如果没有用户声明的移动构造函数或移动赋值运算符，则会自动生成拷贝构造函数（§12.8/8）。

如果没有用户声明的移动构造函数或移动赋值运算符，则会自动生成拷贝赋值运算符（§12.8/19）。

如果没有用户声明的析构函数，则会自动生成析构函数（§12.4/4）。

如果没有用户声明的拷贝构造函数、拷贝赋值运算符或析构函数，并且生成的移动构造函数有效（§12.8/10）。

如果没有用户声明的拷贝构造函数、拷贝赋值运算符或析构函数，并且生成的移动赋值运算符有效（例如，如果它不需要分配常量成员（§12.8/21）。

通常，我们有一个rule of five (C++11加入了后2个):

如果你声明了拷贝构造函数，拷贝赋值运算符，析构函数和移动构造函数，移动赋值函数的五者之一，你应该也声明其余四个。

# 7. 如何在代码中判断当前的编译器是C++编译器还是C编译器

利用宏 `__cplusplus`:

```c++
#ifdef __cplusplus
// 按C++的模式写逻辑
# else
// 按C语言的模式写逻辑或者包装
#endif
```

# 8. C++中的函数传参方式有哪几种

值传递，引用传递和指针传递(有时指针传递也被归类入值传递)

# 9. C++ 中 struct 和 class什么区别

1. 成员的默认权限不同: struct 中成员的默认访问权限是 public, class 是 private
2. 默认继承行为不同: struct 在继承时默认是public 继承, class 是 private 继承 (这里的struct/class指的是派生类的类型，不是基类的类型)。

# 10. 多态的作用

1. 隐藏细节
2. 接口复用

# 11. 面向对象的3个基本特征

1. 封装: 通过不同的权限控制，目的是为了隐藏具体的实现细节
2. 继承: 为了接口复用，和使得派生类可以对基类进行功能扩展
3. 多态: 为了抽象和接口复用。通常认为继承是多态的一种实现方式。

# 12. 引用和指针的区别

1. 引用必须被初始化
2. 引用初始化后，不可被修改

# 13. 重复多次fclose一个打开过一次的FILE *fp指针会有什么结果

因为fclose()会释放fp所指向的内存，所以会引起memory corruption。

# 14. 重复多次close一个打开过一次的fd会有什么结果

第一次close会成功。后续的close会失败，返回-1并置errno为 EBADF。

# 15. 重载(overload)、重写(override)和重定义(redefinition)的区别

重载: 重载有两类，一类是函数重载，指允许存在多个同名，但参数数量或参数类型不同的函数；另一类是运算符重载
重写: 子类和父类有同名、同参数数量和参数类型的函数，这写函数是虚函数
重定义: 和重写一样，只是它们不是虚函数

# 16. C++是否是类型安全的

不是，因为两个不同的指针类型可以通过reinterpret cast 来强制转换。

# 17. const关键字的用法

1. 定义常量，表明此量在初始化后不能修改
2. 修饰函数形参，表明函数不能修改此形参
3. 修饰返回值，表明调用方在获取到本函数的返回值后，不能对这个返回值进行修改
4. 放在指针的类型声明中时，如果放在 "*"的左侧，代表本指针是常量，如果放在右侧，则表示指针指向的内存地址，不能通过本指针修改

# 18.空类大小是多大

是1，因为C++不允许存在0 size的对象:

```c++
class A {};

sizeof(A); // 1
sizeof(void) // 这也是1
```

# 19. 析构函数可不可以是纯虚函数

可以。

# 20. glvalue = lvalue + xvalue, rvalue = prvalue + xvalue

- **lvalue（locator value）**：可以位于赋值表达式的左边或右边，它表示一个对象的身份（identity）。例如，如果你有一个变量，那么这个变量就是一个lvalue。
- **xvalue（expiring value）**：表示一个即将被销毁并且可以被移动的对象。
- **prvalue（pure rvalue）**：只能位于赋值表达式的右边，它表示一个对象的值而不是身份。例如，如果你有一个整数表达式 `5`，那么这个表达式就是一个prvalue。

这三种类型的值可以进一步被归类为：

- **rvalue（right value）**：包括prvalue和xvalue，它们通常表示临时对象或可以被移动的对象。
- **glvalue（generalized lvalue）**：包括lvalue和xvalue，它们表示对象的身份。

这些分类有助于理解C++中的值类别，以及它们如何影响对象的生命周期和移动语义。

# 20. 是不是所有的运算符都能重载

不是

1. `.` 运算符不能重载
2. 重载不能改变运算符原有的行为，比如重载不能改变 `int + int`的行为
