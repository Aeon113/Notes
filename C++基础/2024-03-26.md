# 1.

申请内存(malloc)时，如果堆的扩充大小小于128K, 就使用brk (break)，否则则是mmap。Brk扩张的是堆区（heap区），mmap扩张的是文件映射区。

对于堆上内存(heap区)，glibc会创建内存池管理。

free()的内存，如果处于heap区中，则目标内存会被放回内存池；如果是mmap出来的，则会立刻被munmap掉。

# 2.

静态多态: 函数重载，运算符重载，模板(模板算不算要讨论)

动态多态: 虚函数，std::visit+std::variant(std::visit算不算要讨论)

## 虚函数表

1. 虚函数表在编译时生成(检测到继承链上的某个class拥有virtual修饰的成员函数时就生成)，其存放在.rodata段中。
2. 构造函数中调用虚函数时是没有多态效果的。构造函数调用完成后才会设置vptr。在对象构造过程中，先将vptr指向基类的vtable, 调用基类构造函数，再指向派生类vtable，再调用派生类构造函数。

# 3. ELF的几个主要组成段

1. `.bss` 存放未初始化的或需要初始化为0的全局或静态变量，其在实际执行时，在内存中需要填全0；所以事实上它在程序文件中不占任何空间
2. `.data` 存放需要初始化为非0值的全局或静态变量
3. `.rodata` 存放只读数据，这里面的数据在程序运行期间不变化。虚函数表就放在这里面。
4. `.text` 存放代码

# 4. 进程内存布局

(地址由高到低)

内核空间

栈区

文件映射区

堆区

数据区 (.bss .data)

代码区 (.rodata .text)

# 5. 什么情况会触发拷贝构造函数

```C++
A b;
A a(b); // 这里会触发

A c = b; // 这里也会触发

// 函数按值传参时会触发
// 函数返回值时，如果不满足rvo条件，且也没有移动构造函数，则也会触发
```

# 6. 什么时候编译器会给一个class自动生成拷贝构造函数

这有2组条件(这里存疑):

A. 以下条件必须满足:

1. 这个class没有自定义拷贝构造函数
2. 这个class的定义中没有显式地禁用拷贝构造函数
3. 这个class中没有声明移动构造函数(然而，即使有自定义拷贝赋值，默认拷贝构造还是可以生成)
4. 这个class的所有成员均可拷贝
5. 这个class在其继承链上的基类均可拷贝

B. 以下条件只需要满足一条:

1. 这个class的某个成员拥有拷贝构造函数
2. 这个class继承自某个有拷贝构造函数的class
3. 这个class有虚函数，此时为了拷贝vptr也得生成拷贝构造函数
4. 这个class的继承链的上方，有一个有虚函数的基类

通常，我们有一个rule of five (C++11加入了后2个):

如果你声明了拷贝构造函数，拷贝赋值运算符，析构函数和移动构造函数，移动赋值函数的五者之一，你应该也声明其余四个。

# 7. 如何在代码中判断当前的编译器是C++编译器还是C编译器
利用宏`__cplusplus`:

```c++
#ifdef __cplusplus
// 按C++的模式写逻辑
# else
// 按C语言的模式写逻辑或者包装
#endif
```

# 8. C++中的函数传参方式有哪几种
值传递，引用传递和指针传递(有时指针传递也被归类入值传递)

# 9. C++ 中 struct 和 class什么区别
1. 成员的默认权限不同: struct 中成员的默认访问权限是 public, class 是 private
2. 默认继承行为不同: struct 在继承时默认是public 继承, class 是 private 继承 (这里的struct/class指的是派生类的类型，不是基类的类型)。

# 10. 多态的作用
1. 隐藏细节
2. 接口复用 

# 11. 面向对象的3个基本特征
1. 封装: 通过不同的权限控制，使得外部不能访问类内部的数据和实现 
2. 继承: 为了接口复用
3. 多态: 为了抽象。通常认为继承是多态的一种实现方式。
