# 2022-12-13

## 枚举, match, if let

以下示例定义了**枚举(Enum)** `IpAddrKind`, 它有2个**成员 (variants)** `V4`和 `V6`。

```rust
enum IpAddrKind {
    V4,
    V6,
}

fn main() {
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;

    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}

fn route(ip_kind: IpAddrKind) {}
```

注意枚举的成员位于其标识符的命名空间中，并使用两个冒号分开。

---

和C/C++中的枚举不同, rust中的枚举的base类型不一定是整形。考虑一下代码:

```rust
fn main() {
    enum IpAddrKind {
        V4,
        V6,
    }
    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }
    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };
    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
}
```

通过将枚举 `IpAddrKind`和 `String`组合成一个 `struct`, 实现了IP地址类型(IPV4/IPV6)和IP地址的绑定。

但是, 如果将枚举的基础类型定义为 `String`, 实现会更简洁:

```rust
fn main() {
    enum IpAddr {
        V4(String),
        V6(String),
    }
    let home = IpAddr::V4(String::from("127.0.0.1"));
    let loopback = IpAddr::V6(String::from("::1"));
}
```

我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。这里也很容易看出枚举工作的另一个细节:每一个我们定义的枚举成员的名字也变成了一个构建枚举的实例的函数。也就是说，IpAddr::V4() 是一个获取 String 参数并返回 IpAddr 类型实例的函数调用。作为定义枚举的结果，这些构造函数会自动被定义。

此外, IPV4地址可以看作是4个u8的组合。所以, 也可以这样定义枚举:

```rust
fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));
}
```

可以看出, 枚举中的成员的基类型不要求是相同的。甚至数量也可以有多个。

不过, 标准库中其实也有对ipv4和ipv6地址的定义:

```rust
struct Ipv4Addr {
    // --snip--
}
struct Ipv6Addr {
    // --snip--
}
enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

这些代码展示了可以将任意类型的数据放入枚举成员中:例如字符串、数字类型或者结构体。甚至可以包含另一个枚举。

---

另外, 枚举类型也可以像 `struct`一样拥有方法:

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
impl Message {
    fn call(&self) {
        // Whatever
    }
}
fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```

---

Rust 并没有空值，不过它确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 Option `<T>`，而且它定义于标准库中，如下:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option <T>` 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域。另外，它的成员也是如此，可以不需要 Option:: 前缀来直接使用 Some 和 None。即便如此 Option `<T>` 也仍是常规的枚举，Some(T) 和 None 仍是 Option `<T>` 的成员。

`Option<T>`中的 `<T>`是泛型类型参数。

下面是一些 `Option<T>`的例子:

```rust
fn main() {
    let some_number = Some(5);
    let some_char = Some('e');
    let absent_number : Option<i32> = None;

    println!("{}", some_number.unwrap());
    println!("{}", some_char.unwrap());
    println!("{}", absent_number.unwrap());
}
```

不过这段代码在执行 `absent_number.unwrap()`时会panic。

另外, 上例中使用 `Some`初始化值时, 编译其可以根据括号中的数据类型推断出 `Option`的泛型参数。而当使用 `None`时, 编译器则无法推断。因此在初始化一个值为 `Option<T>::None`时, 需要指定变量的类型。

---

Rust 有一个叫做 `match` 的极为强大的控制流运算符，它允许我们将一个值与一系列的模式相比较，并根据相匹配的模式执行相应代码。模式可由字面值、变量、通配符和许多其他内容构成;第十八章会涉 及到所有不同种类的模式以及它们的作用。`match` 的力量来源于模式的表现力以及编译器检查，它确保了所有可能的情况都得到处理。

以下为一个 `match`和枚举配合使用的例子:

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {}
```

首先，我们列出 `match` 关键字后跟一个表达式，在这个例子中是 `coin` 的值。这看起来非常像 `if` 使用的表达式，不过这里有一个非常大的区别:对于 `if` ，表达式必须返回一个布尔值，而这里它可以是任何类型的。例子中的 `coin` 的类型是 `Coin` 枚举。

接下来是 `match` 的分支。一个分支有两个部分:一个模式和一些代码。第一个分支的模式是值 `Coin::Penny` 而之后的 `=>` 运算符将模式和将要运行的代码分开。这里的代码就仅仅是值1。每一个分支之间使用逗号分隔。

当 match 表达式执行时，它将结果值**按顺序**与每一个分支的模式相比较。如果模式匹配了这个值，这个 模式相关联的代码将被执行。如果模式并不匹配这个值，将继续执行下一个分支。

每个分支相关联的代码是一个表达式，而表达式的结果值将作为整个 match 表达式的返回值。

如果分支代码较短的话通常不使用大括号，如果想要在分 支中运行多行代码，可以使用大括号。而分支里打括号后的逗号是可选的。如下例:

```rust
#![allow(unused)]
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Lucky penny!");
            1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

fn main() {}
```

另外, `enum`也可以派生traits。比如下例就派生了 `Debug` trait。比如下例:

```rust
#![allow(unused)]
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {
    value_in_cents(Coin::Quarter(UsState::Alaska));
}
```

---

我们可以用类似下例的方式来处理 `Option<T>`。

```rust
#![allow(unused)]
fn main() {
    fn plus_one(x: Option<i32>) -> Option<i32> {
        match x {
            None => None,
            Some(i) => Some(i + 1),
        }
    }
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
```

注意, 上例中的函数 `plus_one`定义在函数 `main`内。

另外, 当match后的表达式是一个枚举时, 枚举内的所有成员都必须在此match中有一个分支, 否则编译将不会通过。

---

`match`还可以和整型一起使用, 比如下例:

```rust
#![allow(unused)]
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        other => move_player(),
    }
    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player() {}
}
```

注意, 因为 `i32`类型的值非常多, 我们不可能在 `match`中给它们都建立一个分支, 因此上例中 `match`语句的最后一个分支是 `other`, 它匹配了所有除了3和7的所有值。

另外, 因为 `other`的值我们不需要使用, 所有可以使用rust提供的占位符 `_`, 其作用和 `python`中的 `_`类似。

```rust
#![allow(unused)]
fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => (), // 使用_占位符
    }
    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player() {}
}
```

---

`if let`可以被看作是 `match`的语法糖, 它只关注一个分支, 比如下例代码:

```rust
fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) => println!("The maximum is configured to be {}", max),
        _ => (),
    }
}
```

可以这样改写:

```rust
// #![allow(unused)]
fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!("The maximum is configured to be {}", max);
    }
}
```

另外, `if let`也可以和 `else`以及 `else if`等联合使用。

具体可以参考文档 [if-let-expression](https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions) , 全文摘抄如下:

An if let expression is semantically similar to an if expression but in place of a condition operand it expects the keyword let followed by a pattern, an = and a scrutinee operand. If the value of the scrutinee matches the pattern, the corresponding block will execute. Otherwise, flow proceeds to the following else block if it exists. Like if expressions, if let expressions have a value determined by the block that is evaluated.

```rust
let dish = ("Ham", "Eggs");

// this body will be skipped because the pattern is refuted
if let ("Bacon", b) = dish {
    println!("Bacon is served with {}", b);
} else {
    // This block is evaluated instead.
    println!("No bacon will be served");
}

// this body will execute
if let ("Ham", b) = dish {
    println!("Ham is served with {}", b);
}

if let _ = 5 {
    println!("Irrefutable patterns are always true");
}
```

if and if let expressions can be intermixed:

```rust
let x = Some(3);
let a = if let Some(1) = x {
    1
} else if x == Some(2) {
    2
} else if let Some(y) = x {
    y
} else {
    -1
};
assert_eq!(a, 3);
```

An if let expression is equivalent to a match expression as follows:

```rust
if let PATS = EXPR {
    /* body */
} else {
    /*else */
}
```

is equivalent to

```rust
match EXPR {
    PATS => { /* body */ },
    _ => { /* else */ },    // () if there is no else
}
```

Multiple patterns may be specified with the `|` operator. This has the same semantics as with `|` in match expressions:

```rust
enum E {
    X(u8),
    Y(u8),
    Z(u8),
}
let v = E::Y(12);
if let E::X(n) | E::Y(n) = v {
    assert_eq!(n, 12);
}
```

The expression cannot be a lazy boolean operator expression. Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see eRFC 2947). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:

```rust
// Before...
if let PAT = EXPR && EXPR { .. }

// After...
if let PAT = ( EXPR && EXPR ) { .. }

// Before...
if let PAT = EXPR || EXPR { .. }

// After...
if let PAT = ( EXPR || EXPR ) { .. }
```

---

## 包, crate, 作用域

”作用域(scope)”: 代码所在的嵌套上下文有一组定义为 ”in scope” 的名称。当阅读、编写和编译代码时，程序员和编译器需要知道特定位置的特定名称是否引用了变量、函数、 结构体、枚举、模块、常量或者其他有意义的项。你可以创建作用域，以及改变哪些名称在作用域内还 是作用域外。同一个作用域内不能拥有两个相同名称的项;可以使用一些工具来解决名称冲突。

Rust 有许多功能可以让你管理代码的组织，包括哪些内容可以被公开，哪些内容作为私有部分，以及程 序每个作用域中的名字。这些功能。这有时被称为 ”模块系统(the module system)”，包括:

+ 包(Packages):Cargo 的一个功能，它允许你构建、测试和分享 crate。
+ Crates :一个模块的树形结构，它形成了库或二进制项目。
+ 模块(Modules)和 use:允许你控制作用域和路径的私有性。
+ 路径(path):一个命名例如结构体、函数或模块等项的方式。

---

crate 是 Rust 在编译时最小的代码单位。  

如果你用 rustc 而不是 cargo 来编译一个文件(第一章我们这 么做过)，编译器还是会将那个文件认作一个 crate。crate 可以包含模块，模块可以定义在其他文件，然 后和 crate 一起编译。

crate 有两种形式:二进制项和库。

crate root 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块。
