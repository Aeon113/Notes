# 2022-12-09

Rust ç¼–è¯‘å™¨ä¿è¯ï¼Œå¦‚æœå£°æ˜ä¸€ä¸ªå€¼ä¸ä¼šå˜(å°±æ˜¯ä½¿ç”¨ `let`å£°æ˜æ—¶ä¸åŠ  `mut`)ï¼Œå®ƒå°±çœŸçš„ä¸ä¼šå˜ï¼Œæ‰€ä»¥ä½ ä¸å¿…è‡ªå·±è·Ÿè¸ªå®ƒã€‚è¿™æ„å‘³ç€ä½ çš„ä»£ç æ›´æ˜“äºæ¨å¯¼ã€‚`let mut`ç±»ä¼¼äºCä¸­çš„æ™®é€šå˜é‡ã€‚`let`ç±»ä¼¼äº `const`é‡ã€‚

---

### å¸¸é‡

å¸¸é‡å£°æ˜çš„ç¤ºä¾‹:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

ç±»ä¼¼äºä¸å¯å˜å˜é‡ï¼Œå¸¸é‡ (constants) æ˜¯ç»‘å®šåˆ°ä¸€ä¸ªåç§°çš„ä¸å…è®¸æ”¹å˜çš„å€¼ï¼Œä¸è¿‡å¸¸é‡ä¸å˜é‡è¿˜æ˜¯æœ‰ä¸€äº›åŒºåˆ«ã€‚Rustä¸­çš„å¸¸é‡ç±»ä¼¼äºC++ä¸­çš„ `constexpr`ã€‚

å› æ­¤ä¸å…è®¸å¯¹å¸¸é‡ä½¿ç”¨ mutã€‚å¸¸é‡ä¸å…‰é»˜è®¤ä¸èƒ½å˜ï¼Œå®ƒæ€»æ˜¯ä¸èƒ½å˜; å¸¸é‡åªèƒ½è¢«è®¾ç½®ä¸ºå¸¸é‡è¡¨è¾¾å¼ï¼Œè€Œä¸å¯ä»¥æ˜¯å…¶ä»–ä»»ä½•åªèƒ½åœ¨è¿è¡Œæ—¶è®¡ç®—å‡ºçš„å€¼ã€‚

Rust å¯¹å¸¸é‡çš„å‘½åçº¦å®šæ˜¯åœ¨å•è¯ä¹‹é—´ä½¿ç”¨å…¨å¤§å†™åŠ ä¸‹åˆ’çº¿ã€‚

å¸¸é‡å¯ä»¥åœ¨ä»»ä½•ä½œç”¨åŸŸä¸­å£°æ˜ï¼ŒåŒ…æ‹¬å…¨å±€ä½œç”¨åŸŸï¼Œè¿™åœ¨ä¸€ä¸ªå€¼éœ€è¦è¢«å¾ˆå¤šéƒ¨åˆ†çš„ä»£ç ç”¨åˆ°æ—¶å¾ˆæœ‰ç”¨ã€‚åœ¨å£°æ˜å®ƒçš„ä½œç”¨åŸŸä¹‹ä¸­ï¼Œå¸¸é‡åœ¨æ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸä¸­éƒ½æœ‰æ•ˆï¼Œæ­¤å±æ€§ä½¿å¾—å¸¸é‡å¯ä»¥ä½œä¸ºå¤šå¤„ä»£ç ä½¿ç”¨çš„ å…¨å±€èŒƒå›´çš„å€¼ï¼Œä¾‹å¦‚ä¸€ä¸ªæ¸¸æˆä¸­æ‰€æœ‰ç©å®¶å¯ä»¥è·å–çš„æœ€é«˜åˆ†æˆ–è€…å…‰é€Ÿã€‚

---

### éšè—

æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªä¸ä¹‹å‰å˜é‡åŒåçš„æ–°å˜é‡ã€‚Rustacean ä»¬ç§°ä¹‹ä¸ºç¬¬ä¸€ä¸ªå˜é‡è¢«ç¬¬äºŒä¸ª éšè—(Shadowing)äº†ï¼Œè¿™æ„å‘³ç€å½“æ‚¨ä½¿ç”¨å˜é‡çš„åç§°æ—¶ï¼Œç¼–è¯‘å™¨å°†çœ‹åˆ°ç¬¬äºŒä¸ªå˜é‡ã€‚å®é™…ä¸Šï¼Œç¬¬äºŒä¸ªå˜é‡â€ é®è”½â€ äº†ç¬¬ä¸€ä¸ªå˜é‡ï¼Œæ­¤æ—¶ä»»ä½•ä½¿ç”¨è¯¥å˜é‡åçš„è¡Œä¸ºä¸­éƒ½ä¼šè§†ä¸ºæ˜¯åœ¨ä½¿ç”¨ç¬¬äºŒä¸ªå˜é‡ï¼Œç›´åˆ°ç¬¬äºŒä¸ªå˜é‡è‡ªå·±ä¹Ÿè¢«éšè—æˆ–ç¬¬äºŒä¸ªå˜é‡çš„ä½œç”¨åŸŸç»“æŸã€‚

éšè—çš„ç¤ºä¾‹:

```rust
fn main() {
	let x = 5;
	let x = x + 1;
	{
		let x = x * 2;
        	println!("The value of x in the inner scope is: {x}");
    	}
    	println!("The value of x is: {x}");
}
```

éšè—ä¸å°†å˜é‡æ ‡è®°ä¸º mut æ˜¯æœ‰åŒºåˆ«çš„ã€‚å½“ä¸å°å¿ƒå°è¯•å¯¹å˜é‡é‡æ–°èµ‹å€¼æ—¶ï¼Œå¦‚æœæ²¡æœ‰ä½¿ç”¨ let å…³é”®å­—ï¼Œå°±ä¼šå¯¼è‡´ç¼–è¯‘æ—¶é”™è¯¯ã€‚é€šè¿‡ä½¿ç”¨ letï¼Œæˆ‘ä»¬å¯ä»¥ç”¨è¿™ä¸ªå€¼è¿›è¡Œä¸€äº›è®¡ç®—ï¼Œä¸è¿‡è®¡ç®—å®Œä¹‹åå˜é‡ä»ç„¶æ˜¯ä¸å¯å˜çš„ã€‚

mut ä¸éšè—çš„å¦ä¸€ä¸ªåŒºåˆ«æ˜¯ï¼Œå½“å†æ¬¡ä½¿ç”¨ let æ—¶ï¼Œå®é™…ä¸Šåˆ›å»ºäº†ä¸€ä¸ªæ–°å˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥æ”¹å˜å€¼çš„ç±»å‹ï¼Œå¹¶ä¸”å¤ç”¨è¿™ä¸ªåå­—ã€‚

---

### æ•°æ®ç±»å‹

æˆ‘ä»¬å°†çœ‹åˆ°ä¸¤ç±»æ•°æ®ç±»å‹å­é›†:æ ‡é‡(scalar)å’Œå¤åˆ(compound)ã€‚

#### æ ‡é‡(scalar)ç±»å‹

æ ‡é‡(scalar)ç±»å‹ä»£è¡¨ä¸€ä¸ªå•ç‹¬çš„å€¼ã€‚Rust æœ‰å››ç§åŸºæœ¬çš„æ ‡é‡ç±»å‹:æ•´å‹ã€æµ®ç‚¹å‹ã€å¸ƒå°”ç±»å‹å’Œå­—ç¬¦ç±»å‹ã€‚ä½ å¯èƒ½åœ¨å…¶ä»–è¯­è¨€ä¸­è§è¿‡å®ƒä»¬ã€‚

Rustä¸­çš„æ•´å‹:

| é•¿åº¦    | æœ‰ç¬¦å· | æ— ç¬¦å· |
| ------- | ------ | ------ |
| 8-bit   | i8     | u8     |
| 16-bit  | i16    | u16    |
| 32-bit  | i32    | u32    |
| 64-bit  | i64    | u64    |
| 128-bit | i128   | u128   |
| arch    | isize  | usize  |

æœ‰ç¬¦å·æ•°ä»¥è¡¥ç å½¢å¼(twoâ€™s complement representation)å­˜å‚¨ã€‚

Rust ä¸­çš„æ•´å‹å­—é¢å€¼:

| æ•°å­—å­—é¢å€¼               | ä¾‹å­         |
| ------------------------ | ------------ |
| Decimal(åè¿›åˆ¶)          | 98_222       |
| Hex(åå…­è¿›åˆ¶)            | 0xff         |
| Octal(å…«è¿›åˆ¶)            | 0o77         |
| Binary(äºŒè¿›åˆ¶)           | 0b11111_0000 |
| Byte(å•å­—èŠ‚å­—ç¬¦)(ä»…é™u8) | b'A'         |

Rustçš„é»˜è®¤æ•´å½¢æ˜¯i32ã€‚

å¯¹äºæ•´å½¢æº¢å‡º, åœ¨debugæ¨¡å¼ä¸‹ä¼španic; è€Œåœ¨releaseæ¨¡å¼åˆ™ä¼šwrap aroundã€‚

å¦‚æœéœ€è¦è¿™ç§è¡Œä¸ºï¼Œæ ‡å‡†åº“ä¸­æœ‰ä¸€ä¸ªç±»å‹æ˜¾å¼æä¾›æ­¤åŠŸèƒ½ï¼ŒWrapping(`std::num::Wrapping`)ã€‚ä¸ºäº†æ˜¾å¼åœ°å¤„ç†æº¢å‡ºçš„å¯èƒ½æ€§ï¼Œå¯ä»¥ä½¿ç”¨æ ‡å‡†åº“åœ¨åŸç”Ÿæ•°å€¼ç±»å‹ä¸Šæä¾›çš„ä»¥ä¸‹æ–¹æ³•:

+ æ‰€æœ‰æ¨¡å¼ä¸‹éƒ½å¯ä»¥ä½¿ç”¨ wrapping_* æ–¹æ³•è¿›è¡Œå›ç»•ï¼Œå¦‚ wrapping_add
+ å¦‚æœ checked_* æ–¹æ³•å‡ºç°æº¢å‡ºï¼Œåˆ™è¿”å› Noneå€¼
+ ç”¨ overflowing_* æ–¹æ³•è¿”å›å€¼å’Œä¸€ä¸ªå¸ƒå°”å€¼ï¼Œè¡¨ç¤ºæ˜¯å¦å‡ºç°æº¢å‡º
+ ç”¨ saturating_* æ–¹æ³•åœ¨å€¼çš„æœ€å°å€¼æˆ–æœ€å¤§å€¼å¤„è¿›è¡Œé¥±å’Œå¤„ç†

Rust ä¹Ÿæœ‰ä¸¤ä¸ªåŸç”Ÿçš„ æµ®ç‚¹æ•°(floatingâˆ’point numbers)ç±»å‹ï¼Œå®ƒä»¬æ˜¯å¸¦å°æ•°ç‚¹çš„æ•°å­—ã€‚Rust çš„æµ®ç‚¹æ•°ç±»å‹æ˜¯ f32 å’Œ f64ï¼Œåˆ†åˆ«å  32 ä½å’Œ 64 ä½ã€‚é»˜è®¤ç±»å‹æ˜¯ f64ï¼Œå› ä¸ºåœ¨ç°ä»£ CPU ä¸­ï¼Œå®ƒä¸ f32 é€Ÿåº¦å‡ ä¹ä¸€æ ·ï¼Œä¸è¿‡ç²¾åº¦æ›´é«˜ã€‚æ‰€æœ‰çš„æµ®ç‚¹å‹éƒ½æ˜¯æœ‰ç¬¦å·çš„ã€‚

```rust
fn main() {
	// addition
	let sum = 5 + 10;

	// subtraction
	let difference = 95.5 - 4.3;

	// multiplication
	let product = 4 * 30;

	// division
	let quotient = 56.7 / 32.2;
	let floored = 2 / 3; // Results in 0

	// remainder
	let remainder = 43 % 5;
}
```

æ­£å¦‚å…¶ä»–å¤§éƒ¨åˆ†ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼ŒRust ä¸­çš„å¸ƒå°”ç±»å‹æœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼:true å’Œ falseã€‚Rust ä¸­çš„å¸ƒå°”ç±»å‹ä½¿ç”¨ bool è¡¨ç¤ºã€‚ä¾‹å¦‚:

```rust
fn main() {
	let t = true;
	let f: bool = false; // with explicit type annotation
}
```

Rust çš„ char ç±»å‹æ˜¯è¯­è¨€ä¸­æœ€åŸç”Ÿçš„å­—æ¯ç±»å‹ã€‚Rust çš„ char ç±»å‹çš„å¤§å°ä¸ºå››ä¸ªå­—èŠ‚ (four bytes)ï¼Œå¹¶ä»£è¡¨äº†ä¸€ä¸ª Unicode æ ‡é‡å€¼(Unicode Scalar Value)ï¼Œè¿™æ„å‘³ç€å®ƒå¯ä»¥æ¯” ASCII è¡¨ç¤ºæ›´å¤šå†…å®¹ã€‚åœ¨ Rust ä¸­ï¼Œå¸¦å˜éŸ³ç¬¦å·çš„å­—æ¯(Accented letters)ï¼Œä¸­æ–‡ã€æ—¥æ–‡ã€éŸ©æ–‡ç­‰å­—ç¬¦ï¼Œemoj(iç»˜æ–‡å­—)ä»¥åŠé›¶é•¿åº¦çš„ç©ºç™½å­—ç¬¦éƒ½æ˜¯æœ‰æ•ˆçš„charå€¼ã€‚

ä¸‹é¢æ˜¯ä¸€äº›å£°æ˜ char å€¼çš„ä¾‹å­:

```rust
fn main() {
	let c = 'z';
	let z: char = 'Z'; // with explicit type annotation
	let heart_eyed_cat = 'ğŸ˜»';
}
```

#### å¤åˆç±»å‹(Compound types)

å¤åˆç±»å‹(Compound types)å¯ä»¥å°†å¤šä¸ªå€¼ç»„åˆæˆä¸€ä¸ªç±»å‹ã€‚Rust æœ‰ä¸¤ä¸ªåŸç”Ÿçš„å¤åˆç±»å‹:å…ƒç»„(tuple)å’Œæ•°ç»„(array)ã€‚

##### å…ƒç»„

å…ƒç»„æ˜¯ä¸€ä¸ªå°†å¤šä¸ªå…¶ä»–ç±»å‹çš„å€¼ç»„åˆè¿›ä¸€ä¸ªå¤åˆç±»å‹çš„ä¸»è¦æ–¹å¼ã€‚å…ƒç»„é•¿åº¦å›ºå®š:ä¸€æ—¦å£°æ˜ï¼Œå…¶é•¿åº¦ä¸ä¼šå¢å¤§æˆ–ç¼©å°ã€‚æˆ‘ä»¬ä½¿ç”¨åŒ…å«åœ¨åœ†æ‹¬å·ä¸­çš„é€—å·åˆ†éš”çš„å€¼åˆ—è¡¨æ¥åˆ›å»ºä¸€ä¸ªå…ƒç»„ã€‚å…ƒç»„ä¸­çš„æ¯ä¸€ä¸ªä½ç½®éƒ½æœ‰ä¸€ä¸ªç±»å‹ï¼Œè€Œä¸”è¿™äº›ä¸åŒå€¼çš„ç±»å‹ä¹Ÿä¸å¿…æ˜¯ç›¸åŒçš„ã€‚è¿™ä¸ªä¾‹å­ä¸­ä½¿ç”¨äº†å¯é€‰çš„ç±»å‹æ³¨è§£:

```rust
fn main() {
	let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

tup å˜é‡ç»‘å®šåˆ°æ•´ä¸ªå…ƒç»„ä¸Šï¼Œå› ä¸ºå…ƒç»„æ˜¯ä¸€ä¸ªå•ç‹¬çš„å¤åˆå…ƒç´ ã€‚ä¸ºäº†ä»å…ƒç»„ä¸­è·å–å•ä¸ªå€¼ï¼Œå¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…(pattern matching)æ¥è§£æ„(destructure)å…ƒç»„å€¼ï¼Œåƒè¿™æ ·:

```rust
fn main() {
	let tup = (500, 6.4, 1);
	let (x, y, z) = tup;
	println!("The value of y is: {y}");
}
```

ç¨‹åºé¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªå…ƒç»„å¹¶ç»‘å®šåˆ° tup å˜é‡ä¸Šã€‚æ¥ç€ä½¿ç”¨äº† let å’Œä¸€ä¸ªæ¨¡å¼å°† tup åˆ†æˆäº†ä¸‰ä¸ªä¸åŒçš„å˜é‡ï¼Œxã€y å’Œ zã€‚è¿™å«åš è§£æ„(destructuring)ï¼Œå› ä¸ºå®ƒå°†ä¸€ä¸ªå…ƒç»„æ‹†æˆäº†ä¸‰ä¸ªéƒ¨åˆ†ã€‚æœ€åï¼Œç¨‹åºæ‰“å°å‡ºäº†y çš„å€¼ï¼Œä¹Ÿå°±æ˜¯ 6.4ã€‚

æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ç‚¹å·( . )åè·Ÿå€¼çš„ç´¢å¼•æ¥ç›´æ¥è®¿é—®å®ƒä»¬ã€‚ä¾‹å¦‚:

```rust
fn main() {
	let x: (i32, f64, u8) = (500, 6.4, 1);
	let five_hundred = x.0;
	let six_point_four = x.1;
	let one = x.2;
}
```

ä¸å¸¦ä»»ä½•å€¼çš„å…ƒç»„æœ‰ä¸ªç‰¹æ®Šçš„åç§°ï¼Œå«åš å•å…ƒ(unit)å…ƒç»„ã€‚è¿™ç§å€¼ä»¥åŠå¯¹åº”çš„ç±»å‹éƒ½å†™ä½œ `()` ï¼Œè¡¨ç¤ºç©ºå€¼æˆ–ç©ºçš„è¿”å›ç±»å‹ã€‚å¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼ï¼Œåˆ™ä¼šéšå¼è¿”å›å•å…ƒå€¼ã€‚

##### æ•°ç»„

Rust ä¸­çš„æ•°ç»„é•¿åº¦æ˜¯å›ºå®šçš„ã€‚æˆ‘ä»¬å°†æ•°ç»„å†™åœ¨æ–¹æ‹¬å·é‡Œ:

```rust
fn main() {
	let a = [1, 2, 3, 4]; // a ä¸ºä¸€ä¸ªå«æœ‰4ä¸ªi32çš„æ•°ç»„
	let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; // months æ˜¯å«æœ‰3ä¸ªstrçš„æ•°ç»„
	let c: [i32; 5] = [1, 2, 3, 4, 5]; // c æ˜¯ä¸€ä¸ªå«æœ‰5ä¸ªi32çš„æ•°ç»„
	let d: [3; 5]; // ç­‰ä»·äº let d = [3, 3, 3, 3, 3];

	// ä½¿ç”¨ä¸­æ‹¬å·æ¥è®¿é—®æ•°ç»„ä¸­çš„å…ƒç´ :
	let first = a[0];
	let second = a[1];
}
```

æ•°ç»„è®¿é—®è¶Šç•Œä¼šå¼•èµ·panicã€‚

### å‡½æ•°

Rustä½¿ç”¨fnæ¥å£°æ˜å‡½æ•°ã€‚Rustç¨‹åºçš„å…¥å£å‡½æ•°æ˜¯mainã€‚Rust ä»£ç ä¸­çš„å‡½æ•°å’Œå˜é‡åä½¿ç”¨ snake case è§„èŒƒé£æ ¼ã€‚åœ¨ snake case ä¸­ï¼Œæ‰€æœ‰å­—æ¯éƒ½æ˜¯å°å†™å¹¶ä½¿ç”¨ä¸‹åˆ’çº¿åˆ†éš”å•è¯ã€‚

```rust
fn main() {
	println!("Hello, world!");
	another_function();
}

fn another_function() {
	println!("Another function.");
}
```

æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸ºæ‹¥æœ‰ å‚æ•°(parameters)çš„å‡½æ•°ï¼Œå‚æ•°æ˜¯ç‰¹æ®Šå˜é‡ï¼Œæ˜¯å‡½æ•°ç­¾åçš„ä¸€éƒ¨åˆ†ã€‚å½“å‡½æ•°æ‹¥æœ‰å‚æ•°(å½¢å‚)æ—¶ï¼Œå¯ä»¥ä¸ºè¿™äº›å‚æ•°æä¾›å…·ä½“çš„å€¼(å®å‚)ã€‚æŠ€æœ¯ä¸Šè®²ï¼Œè¿™äº›å…·ä½“å€¼è¢«ç§°ä¸ºå‚æ•°(arguments)ï¼Œä½†æ˜¯åœ¨æ—¥å¸¸äº¤æµä¸­ï¼Œäººä»¬å€¾å‘äºä¸åŒºåˆ†ä½¿ç”¨ parameter å’Œ argument æ¥è¡¨ç¤ºå‡½æ•°å®šä¹‰ä¸­çš„å˜é‡æˆ–è°ƒç”¨å‡½æ•°æ—¶ä¼ å…¥çš„å…·ä½“å€¼ã€‚

åœ¨å‡½æ•°ç­¾åä¸­ï¼Œå¿…é¡»å£°æ˜æ¯ä¸ªå‚æ•°çš„ç±»å‹ã€‚

```rust
fn main() {
    print_labeled_measurement(5, 'h');
}
fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}
```

---

å‡½æ•°ä½“ç”±ä¸€ç³»åˆ—çš„è¯­å¥å’Œä¸€ä¸ªå¯é€‰çš„ç»“å°¾è¡¨è¾¾å¼æ„æˆã€‚ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬æåˆ°çš„å‡½æ•°è¿˜ä¸åŒ…å«ç»“å°¾è¡¨è¾¾å¼ï¼Œä¸è¿‡ä½ å·²ç»è§è¿‡ä½œä¸ºè¯­å¥ä¸€éƒ¨åˆ†çš„è¡¨è¾¾å¼ã€‚å› ä¸º Rust æ˜¯ä¸€é—¨åŸºäºè¡¨è¾¾å¼(expression-based)çš„è¯­è¨€ï¼Œè¿™æ˜¯ä¸€ä¸ªéœ€è¦ç†è§£çš„(ä¸åŒäºå…¶ä»–è¯­è¨€)é‡è¦åŒºåˆ«ã€‚å…¶ä»–è¯­è¨€å¹¶æ²¡æœ‰è¿™æ ·çš„åŒºåˆ«ï¼Œæ‰€ä»¥è®©æˆ‘ä»¬çœ‹çœ‹è¯­å¥ä¸è¡¨è¾¾å¼æœ‰ä»€ä¹ˆåŒºåˆ«ä»¥åŠè¿™äº›åŒºåˆ«æ˜¯å¦‚ä½•å½±å“å‡½æ•°ä½“çš„ã€‚

è¯­å¥(Statements)æ˜¯æ‰§è¡Œä¸€äº›æ“ä½œä½†ä¸è¿”å›å€¼çš„æŒ‡ä»¤ã€‚è¡¨è¾¾å¼(Expressions)è®¡ç®—å¹¶äº§ç”Ÿä¸€ä¸ªå€¼ã€‚

å®é™…ä¸Šï¼Œæˆ‘ä»¬å·²ç»ä½¿ç”¨è¿‡è¯­å¥å’Œè¡¨è¾¾å¼ã€‚ä½¿ç”¨ let å…³é”®å­—åˆ›å»ºå˜é‡å¹¶ç»‘å®šä¸€ä¸ªå€¼æ˜¯ä¸€ä¸ªè¯­å¥ã€‚åœ¨ä¸‹ä¾‹ä¸­ï¼Œlet y = 6; æ˜¯ä¸€ä¸ªè¯­å¥ã€‚

```rust
fn main() {
	let y = 6;
}
```

å‡½æ•°å®šä¹‰ä¹Ÿæ˜¯è¯­å¥ï¼Œä¸Šé¢æ•´ä¸ªä¾‹å­æœ¬èº«å°±æ˜¯ä¸€ä¸ªè¯­å¥ã€‚

è¯­å¥ä¸è¿”å›å€¼ã€‚å› æ­¤ï¼Œä¸èƒ½æŠŠ let è¯­å¥èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡ï¼Œæ¯”å¦‚ä¸‹é¢çš„ä¾‹å­å°è¯•åšçš„ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯:

```rust
fn main() {
	let x = (let y = 6);
}
```

è€Œè¡¨è¾¾å¼ä¼šè®¡ç®—å‡ºä¸€ä¸ªå€¼ï¼Œå¹¶ä¸”ä½ å°†ç¼–å†™çš„å¤§éƒ¨åˆ† Rust ä»£ç æ˜¯ç”±è¡¨è¾¾å¼ç»„æˆçš„ã€‚å‡½æ•°è°ƒç”¨æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚å®è°ƒç”¨æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚ç”¨å¤§æ‹¬å·åˆ›å»ºçš„ä¸€ä¸ªæ–°çš„å—ä½œç”¨åŸŸä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¾‹å¦‚:

```rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };
    println!("The value of y is {}", y);
}
```

å…¶ä¸­çš„

```rust
{
    let x = 3;
    x + 1
};
```

æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼, æ›´å…·ä½“çš„è¯´, æ˜¯ä»£ç å—ã€‚å®ƒçš„å€¼æ˜¯4ã€‚å…¶ä¸­çš„æœ€åä¸€è¡Œ `x + 1`æ²¡æœ‰åˆ†å·ã€‚è€Œå¦‚æœç»™å®ƒåŠ ä¸Šåˆ†å·, å°±å˜æˆäº†ä¸€ä¸ªè¯­å¥ã€‚è€Œè¯­å¥æ²¡æœ‰è¿”å›å€¼ã€‚

å‡½æ•°å¯ä»¥å‘è°ƒç”¨å®ƒçš„ä»£ç è¿”å›å€¼ã€‚æˆ‘ä»¬å¹¶ä¸å¯¹è¿”å›å€¼å‘½åï¼Œä½†è¦åœ¨ç®­å¤´(âˆ’>)åå£°æ˜å®ƒçš„ç±»å‹ã€‚

åœ¨ Rustä¸­ï¼Œå‡½æ•°çš„è¿”å›å€¼ç­‰åŒäºå‡½æ•°ä½“æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ã€‚ä½¿ç”¨ return å…³é”®å­—å’ŒæŒ‡å®šå€¼ï¼Œå¯ä»å‡½æ•°ä¸­æå‰è¿”å›;ä½†å¤§éƒ¨åˆ†å‡½æ•°éšå¼çš„è¿”å›æœ€åçš„è¡¨è¾¾å¼ã€‚

ä¸‹ä¾‹æ˜¯è°ƒç”¨æœ‰è¿”å›å€¼çš„å‡½æ•°çš„ä¾‹å­:

```rust
fn main() {
    let x = five();
    println!("Value is {}", x);
    let x = six();
    println!("Value is {}", x);
}

fn five() -> i32 {
    return 5
}

fn six() -> u32 {
    6
}
```

å¦‚æœæˆ‘ä»¬åœ¨ `6`ååŠ ä¸Šä¸€ä¸ªåˆ†å·, å®ƒå°±ä»è¡¨è¾¾å¼å˜æˆäº†è¯­å¥ã€‚ç¼–è¯‘å°†ä¼šæŠ¥é”™ã€‚

```rust
fn main() {
    let x = five();
    println!("Value is {}", x);
    let x = six();
    println!("Value is {}", x);
}

fn five() -> i32 {
    return 5
}

fn six() -> u32 {
    6; // æ³¨æ„è¿™é‡Œ, ä¼šæŠ¥é”™
}
```

ç¼–è¯‘æŠ¥é”™:

```plaintext
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
error[E0308]: mismatched types
  --> src/main.rs:12:13
   |
12 | fn six() -> u32 {
   |    ---      ^^^ expected `u32`, found `()`
   |    |
   |    implicitly returns `()` as its body has no tail or `return` expression
13 |     6;
   |      - help: remove this semicolon

For more information about this error, try `rustc --explain E0308`.
error: could not compile `hello_cargo` due to previous error
```

ä¸»è¦çš„é”™è¯¯ä¿¡æ¯ï¼Œâ€mismatched typesâ€(ç±»å‹ä¸åŒ¹é…)ï¼Œæ­ç¤ºäº†ä»£ç çš„æ ¸å¿ƒé—®é¢˜ã€‚å‡½æ•° plus_one çš„å®šä¹‰è¯´æ˜å®ƒè¦è¿”å›ä¸€ä¸ª i32 ç±»å‹çš„å€¼ï¼Œä¸è¿‡è¯­å¥å¹¶ä¸ä¼šè¿”å›å€¼ï¼Œä½¿ç”¨å•ä½ç±»å‹ () è¡¨ç¤ºä¸è¿”å›å€¼ã€‚å› ä¸ºä¸è¿”å›å€¼ä¸å‡½æ•°å®šä¹‰ç›¸çŸ›ç›¾ï¼Œä»è€Œå‡ºç°ä¸€ä¸ªé”™è¯¯ã€‚åœ¨è¾“å‡ºä¸­ï¼ŒRust æä¾›äº†ä¸€æ¡ä¿¡æ¯ï¼Œå¯èƒ½æœ‰åŠ©äºçº æ­£è¿™ä¸ªé”™è¯¯: å®ƒå»ºè®®åˆ é™¤åˆ†å·ï¼Œè¿™ä¼šä¿®å¤è¿™ä¸ªé”™è¯¯ã€‚

ä¸è¿‡åœ¨ `return 5`åé¢åŠ åˆ†å·æ²¡é—®é¢˜ã€‚

### æ§åˆ¶æµ

---

#### if è¡¨è¾¾å¼

rustä¹Ÿå¯ä»¥ä½¿ç”¨ `if`, `else`, `else if`, ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹:

```rust
fn main() {
    let number = 6;
    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```

Rustä¸­ `if`çš„æ¡ä»¶ å¿…é¡»æ˜¯ bool å€¼ã€‚å¦‚æœæ¡ä»¶ä¸æ˜¯ bool å€¼ï¼Œæˆ‘ä»¬å°†å¾—åˆ°ä¸€ä¸ªé”™è¯¯ã€‚

å› ä¸ºifæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼, æ‰€ä»¥ä¹Ÿå¯ä»¥è¢«æ”¾åœ¨letè¯­å¥ä¸­ç”¨äºèµ‹å€¼:

```rust
use std::io;
fn main() {
    let mut val : String = String::new();
    println!("Enter an integer:");
    io::stdin().read_line(&mut val).expect("Cannot get line");
    let val : i32 = val.trim().parse().expect("This is not an integer!");
    let res = if val % 2 == 0 { 1 } else { 0 };
    println!("val = {val}, res = {res}");
}
```

ä»£ç å—çš„å€¼æ˜¯å…¶ä¸­æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ã€‚ä¸Šä¾‹ä¸­çš„ `{ 1 }`çš„å€¼æ˜¯ `1`, `{ 0 }`æ˜¯0ã€‚

æ³¨æ„, å¦‚æœæˆ‘ä»¬æŠŠä¸Šä¾‹ä¸­çš„ `else { 0 }`æ”¹æˆ `else { "0" }`, ä½¿å¾— `if`åˆ†æ”¯ä»£ç å—çš„å€¼å’Œ `else`åˆ†æ”¯çš„ä»£ç å—çš„ç±»å‹ä¸åŒ, å°±ä¼šæŠ¥é”™ã€‚

```rust
use std::io;
fn main() {
    let mut val : String = String::new();
    println!("Enter an integer:");
    io::stdin().read_line(&mut val).expect("Cannot get line");
    let val : i32 = val.trim().parse().expect("This is not an integer!");
    let res = if val % 2 == 0 { 1 } else { "0" };
    println!("val = {val}, res = {res}");
}
```

```plaintext
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
error[E0308]: `if` and `else` have incompatible types
 --> src/main.rs:7:44
  |
7 |     let res = if val % 2 == 0 { 1 } else { "0" };
  |                                 -          ^^^ expected integer, found `&str`
  |                                 |
  |                                 expected because of this

For more information about this error, try `rustc --explain E0308`.
error: could not compile `hello_cargo` due to previous error
```

æŠ¥é”™çš„åŸå› æ˜¯rustæ— æ³•åœ¨ç¼–è¯‘æ—¶æ¨å¯¼å‡ºresçš„ç±»å‹ã€‚

---

#### å¾ªç¯

Rustæä¾›3ç§å¾ªç¯ç±»å‹: `loop`, `while`, `for`ã€‚

å’ŒC/C++ä¸€æ ·, rustä¹Ÿæä¾›äº† `break`å’Œ `continue`è¯­å¥ã€‚

`loop`ä¼šä¸åœå¾ªç¯ç›´åˆ°æœ‰æ˜ç¡®å¯ä»¥è·³å‡ºå¾ªç¯çš„è¯­å¥/è¡¨è¾¾å¼ã€‚(`return`ã€`break`ç­‰)ã€‚

```rust
fn main() {
	loop {
		println!("again!");
    	}
}
```

å› ä¸º `loop`è¯­å¥ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼, æ‰€ä»¥å®ƒä¹Ÿå¯ä»¥æœ‰å€¼, ä¹Ÿå¯ä»¥è¢«ç”¨äºletè¯­å¥ã€‚ä¸€ä¸ªloopå¾ªç¯ä½“çš„å€¼å¯ä»¥åœ¨å…¶breakåæ¥ä¸Š:

```rust
fn main() {
    let mut tmp : u64 = 1;
    const COUNT : u64 = 10;
    let mut i : u64 = 0;
    let result =
    loop {
        if i == COUNT {
            break tmp;
        }
        i += 1;
        tmp *= i;
    };

    println!("Result = {}", result);
}
```

---

åµŒå¥—å¾ªç¯ã€å¾ªç¯æ ‡ç­¾

Rustä¸­continue å’Œ loop çš„è¡Œä¸ºå’ŒC/C++ä¸€è‡´, å¦‚æœæœ‰å¤šå±‚å¾ªç¯åµŒå¥—, å®ƒä»¬å°†åªä½œç”¨äºæœ€å†…å±‚çš„å¾ªç¯ã€‚

Rustä¹Ÿå¯ä»¥ç»™å¾ªç¯åŠ ä¸Šæ ‡ç­¾, è¿™æ ·å°±å¯ä»¥åœ¨å†…å±‚å¾ªç¯ä¸­ç›´æ¥break/continueå¤–å±‚å¾ªç¯ã€‚

```rust
fn main() {
    let mut count = 0; 'counting_up: loop { println!("count = {count}");
        let mut remaining = 10; loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }
        count += 1;
    }
    println!("End count = {count}");
}
```

whileå¾ªç¯åˆ™æ˜¯åœ¨æ¡ä»¶ä¸ºçœŸæ—¶è¿›è¡Œ, åœ¨æ¡ä»¶ä¸ºå‡æ—¶è‡ªåŠ¨é€€å‡ºã€‚

```rust
fn main() {
    let mut number = 3;

    while number != 0 {
        println!("{number}!");
        number -= 1;
    }
    println!("LIFTOFF!!!");
}
```

forå¾ªç¯åˆ™ç±»ä¼¼äºpythonä¸­çš„foreachå¾ªç¯, ç”¨æ¥éå†é›†åˆ:

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;
    while index < 5 {
        println!("the value is: {}", a[index]);
        index += 1;
    }
}
```

ä¸€ç§å¸¸ä¸forå¾ªç¯ä¸€åŒé…åˆä½¿ç”¨çš„ç±»å‹æ˜¯ `Range`, å®ƒç”±æ ‡å‡†åº“æä¾›, ç”¨æ¥ç”Ÿæˆä»ä¸€ä¸ªæ•°å­—å¼€å§‹åˆ°å¦ä¸€ä¸ªæ•°å­—ç»“æŸçš„æ‰€æœ‰æ•°å­—çš„æ’åˆ—ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªforå¾ªç¯å’ŒRangeé…åˆä½¿ç”¨çš„ä¾‹å­ã€‚é‡Œé¢è¿˜ä½¿ç”¨äº†Rangeçš„revæ–¹æ³•, ç”¨æ¥åè½¬range:

```rust
fn main() {
    for number in (1..4).rev() {
        println!("{}!", number);
    }

    println!("LIFTOFF!!");
}
```

### æ‰€æœ‰æƒ

#### Rust æ‰€æœ‰æƒè§„åˆ™:

1. Rustä¸­çš„æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…(owner)ã€‚
2. å€¼åœ¨ä»»ä½•æ—¶åˆ»éƒ½åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ã€‚
3. å½“æ‰€æœ‰è€…(å˜é‡)ç¦»å¼€ä½œç”¨åŸŸ, è¿™ä¸ªå€¼å°†è¢«ä¸¢å¼ƒã€‚

---

Rustçš„ä½œç”¨åŸŸçš„å®šä¹‰ä¸å…¶ä»–è¯­è¨€ç±»ä¼¼, ä¹Ÿç”¨ä¸€å¯¹å¤§æ‹¬å·æ¥æ ‡è¯†ã€‚

åœ¨ç¦»å¼€ä¸€ä¸ªå˜é‡çš„ä½œç”¨åŸŸæ—¶, Rustä¼šä¸ºæ­¤ä½œç”¨åŸŸå†…çš„æ‰€æœ‰å˜é‡è°ƒç”¨ä¸€ä¸ªç‰¹æ®Šå‡½æ•°, å«åš `drop`ã€‚

è¿™ä¸ªè¿‡ç¨‹ç±»ä¼¼äºRAIIã€‚

---

å¯¹äºæ²¡æœ‰å®ç°copy traitçš„ç±»å‹çš„"="æ“ä½œ, rustå®ç°çš„æ˜¯ç±»ä¼¼äºc++ä¸­çš„ç§»åŠ¨è¯­ä¹‰ã€‚æ¯”å¦‚ä¸‹ä¾‹:

```rust
fn main() {
    let s1 = String::from("Hi!!!");
    let s2 = s1;
    println!("{s1}");
}
```

 `let s2 = s1`ä½¿ç”¨s1"ç§»åŠ¨æ„é€ "äº†s2ã€‚ä¸”rustä¿è¯å› è¿™ç§ç§»åŠ¨è¯­ä¹‰è€Œå¤±æ•ˆçš„å¯¹è±¡ä¸å¯å†è¢«è®¿é—®ã€‚å› æ­¤, ä¸Šä¾‹ä»£ç ç¼–è¯‘ä¼šæŠ¥é”™:

```plaintext
   Compiling string_ownership v0.1.0 (/Users/aeon/projects/string_ownership)
warning: unused variable: `s2`
 --> src/main.rs:3:9
  |
3 |     let s2 = s1;
  |         ^^ help: if this is intentional, prefix it with an underscore: `_s2`
  |
  = note: `#[warn(unused_variables)]` on by default

error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:4:16
  |
2 |     let s1 = String::from("Hi!!!");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |     println!("{s1}");
  |                ^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
warning: `string_ownership` (bin "string_ownership") generated 1 warning
error: could not compile `string_ownership` due to previous error; 1 warning emitted
```

è¿™ç§ç§»åŠ¨çš„æ‰€æœ‰æƒè½¬ç§»æ¨¡å¼, ä¹Ÿè¡¨æ˜, rustä¸ä¼šè‡ªåŠ¨ç”Ÿæˆå¯¹æ•°æ®çš„æ·±æ‹·è´ã€‚

å¦‚æœç¡®å®éœ€è¦è¿›è¡Œå¯¹è±¡çš„æ‹·è´, åˆ™éœ€è¦å®ç°è¯¥ç±»å‹çš„ `clone`æ–¹æ³•ã€‚ä¸”éœ€è¦ä½¿ç”¨ `clone`æ¥æ„é€ æ–°å¯¹è±¡:

```rust
fn main() {
    let s1 = String::from("Hi!!!");
    let s2 = s1.clone();
    println!("{s1}");
    println!("{s2}");
}
```

å¦å¤–, åˆšæ‰æåˆ°äº†"copy trait"ã€‚Rust æœ‰ä¸€ä¸ªå«åš Copy trait çš„ç‰¹æ®Šæ³¨è§£ï¼Œå¯ä»¥ç”¨åœ¨ç±»ä¼¼æ•´å‹è¿™æ ·çš„å­˜å‚¨åœ¨æ ˆä¸Šçš„ç±»å‹ä¸Šã€‚å¦‚æœä¸€ä¸ªç±»å‹å®ç°äº† Copy traitï¼Œé‚£ä¹ˆä¸€ä¸ªæ—§çš„å˜é‡åœ¨å°†å…¶èµ‹å€¼ç»™å…¶ä»–å˜é‡åä»ç„¶å¯ç”¨ã€‚

Rust ä¸å…è®¸è‡ªèº«æˆ–å…¶ä»»ä½•éƒ¨åˆ†å®ç°äº† Drop trait çš„ç±»å‹ä½¿ç”¨ Copy traitã€‚å¦‚æœæˆ‘ä»¬å¯¹å…¶å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ éœ€è¦ç‰¹æ®Šå¤„ç†çš„ç±»å‹ä½¿ç”¨ Copy æ³¨è§£ï¼Œå°†ä¼šå‡ºç°ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯ã€‚è¦å­¦ä¹ å¦‚ä½•ä¸ºä½ çš„ç±»å‹æ·»åŠ  Copy æ³¨ è§£ä»¥å®ç°è¯¥ traitï¼Œè¯·é˜…è¯»é™„å½• C ä¸­çš„ â€ å¯æ´¾ç”Ÿçš„ traitâ€ã€‚

Rust ä¸å…è®¸è‡ªèº«æˆ–å…¶ä»»ä½•éƒ¨åˆ†å®ç°äº† Drop trait çš„ç±»å‹ä½¿ç”¨ Copy traitã€‚å¦‚æœæˆ‘ä»¬å¯¹å…¶å€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ éœ€è¦ç‰¹æ®Šå¤„ç†çš„ç±»å‹ä½¿ç”¨ Copy æ³¨è§£ï¼Œå°†ä¼šå‡ºç°ä¸€ä¸ªç¼–è¯‘æ—¶é”™è¯¯ã€‚è¦å­¦ä¹ å¦‚ä½•ä¸ºä½ çš„ç±»å‹æ·»åŠ  Copy æ³¨ è§£ä»¥å®ç°è¯¥ traitï¼Œè¯·é˜…è¯»é™„å½• C ä¸­çš„ â€ å¯æ´¾ç”Ÿçš„ traitâ€ã€‚

é‚£ä¹ˆå“ªäº›ç±»å‹å®ç°äº† Copy trait å‘¢ï¼Ÿä½ å¯ä»¥æŸ¥çœ‹ç»™å®šç±»å‹çš„æ–‡æ¡£æ¥ç¡®è®¤ï¼Œä¸è¿‡ä½œä¸ºä¸€ä¸ªé€šç”¨çš„è§„åˆ™ï¼Œä»»ä½• ä¸€ç»„ç®€å•æ ‡é‡å€¼çš„ç»„åˆéƒ½å¯ä»¥å®ç° Copyï¼Œä»»ä½•ä¸éœ€è¦åˆ†é…å†…å­˜æˆ–æŸç§å½¢å¼èµ„æºçš„ç±»å‹éƒ½å¯ä»¥å®ç° Copy ã€‚å¦‚ä¸‹æ˜¯ä¸€äº› Copy çš„ç±»å‹ï¼š

1. æ‰€æœ‰æ•´æ•°ç±»å‹ã€‚
2. Boolç±»å‹ã€‚
3. æµ®ç‚¹æ•°ç±»å‹ã€‚
4. å­—ç¬¦ç±»å‹ã€‚
5. å…ƒç»„, ä¸”å…¶æ‰€æœ‰æˆå‘˜ä¹Ÿéƒ½ä¸ºä¸Šè¿°4ç±»æˆå‘˜æˆ–æ»¡è¶³æ­¤æ¡ä»¶çš„å…ƒç»„ã€‚

---

å‡½æ•°è°ƒç”¨æ—¶çš„å‚æ•°ä¹Ÿéµå¾ªä¸Šè¿°åŸåˆ™ã€‚æ¯”å¦‚å¦‚æœå‡½æ•°Aè°ƒç”¨äº†å‡½æ•°B, ä¸”å‘å…¶ä¼ é€’äº†å‚æ•°xã€‚å¦‚æœBæŒ‰å€¼æ•è·äº†x, çš„è¯, é‚£ä¹ˆåœ¨è°ƒç”¨æ—¶, xçš„æ‰€æœ‰æƒå°±ä»å‡½æ•°Aè½¬ç§»åˆ°äº†å‡½æ•°Bä¸­ã€‚ä¸”åœ¨å‡½æ•°Bè¿”å›æ—¶, å› ä¸ºç¦»å¼€äº†å‡½æ•°Bçš„æœ€å¤–å±‚å¤§æ‹¬å·(å®šä¹‰åŸŸ), è¿™ä¸ªå¯¹è±¡ä¼šè¢«é”€æ¯ã€‚å¦‚æœAå°è¯•åœ¨è°ƒç”¨Bå, å†æ¬¡è®¿é—®å˜é‡x, ç¼–è¯‘å™¨å°±ä¼šæŠ¥é”™ã€‚

---

å‡½æ•°è¿”å›å€¼, ä¹Ÿä¼šå¼•èµ·æ‰€æœ‰æƒçš„è½¬ç§»:

```rust
fn main() {
    let s1 = gives_ownership();                             // gives_ownership å°†è¿”å›å€¼
                                                            // è½¬ç§»ç»™ s1

    let s2 = String::from("hello");                         // s2 è¿›å…¥ä½œç”¨åŸŸ
    let s3 = takes_and_gives_back(s2);


                                                            // s2 è¢«ç§»åŠ¨åˆ°
                                                            // takes_and_gives_back ä¸­,
                                                            // å®ƒä¹Ÿå°†è¿”å›å€¼ç§»ç»™ s3
} // è¿™é‡Œ, s3 ç§»å‡ºä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒã€‚s2 ä¹Ÿç§»å‡ºä½œç”¨åŸŸï¼Œä½†å·²è¢«ç§»èµ°ï¼Œ
  // æ‰€ä»¥ä»€ä¹ˆä¹Ÿä¸ä¼šå‘ç”Ÿã€‚s1 ç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«ä¸¢å¼ƒ

fn gives_ownership() -> String {                            // gives_ownership ä¼šå°†
                                                            // è¿”å›å€¼ç§»åŠ¨ç»™
                                                            // è°ƒç”¨å®ƒçš„å‡½æ•°

    let some_string = String::from("yours");                // some_string è¿›å…¥ä½œç”¨åŸŸ.
    some_string                                             // è¿”å› some_string
                                                            // å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}

// takes_and_gives_back å°†ä¼ å…¥å­—ç¬¦ä¸²å¹¶è¿”å›è¯¥å€¼
fn takes_and_gives_back(a_string: String) -> String {       // a_string è¿›å…¥ä½œç”¨åŸŸ
                                                            //

    a_string                                                // è¿”å› a_string å¹¶ç§»å‡ºç»™è°ƒç”¨çš„å‡½æ•°
}
```

åœ¨å‡½æ•° `gives_ownership`å’Œ `takes_and_gives_back`é€€å‡ºæ—¶, `some_string`å’Œ `a_string`ä¸ä¼šè¢«è°ƒç”¨ `drop`æ–¹æ³•åˆ é™¤æ‰, è€Œæ˜¯ä¼šè¢«è¿”å›ç»™ä¸Šå±‚å‡½æ•°ã€‚

å˜é‡çš„æ‰€æœ‰æƒæ€»æ˜¯éµå¾ªç›¸åŒçš„æ¨¡å¼ï¼šå°†å€¼èµ‹ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ç§»åŠ¨å®ƒã€‚å½“æŒæœ‰å †ä¸­æ•°æ®å€¼çš„å˜é‡ç¦»å¼€ä½œç”¨ åŸŸæ—¶ï¼Œå…¶å€¼å°†é€šè¿‡ drop è¢«æ¸…ç†æ‰ï¼Œé™¤éæ•°æ®è¢«ç§»åŠ¨ä¸ºå¦ä¸€ä¸ªå˜é‡æ‰€æœ‰ã€‚

---

Rustçš„å¼•ç”¨(reference)å’ŒC++çš„å¼•ç”¨, é€»è¾‘ç±»ä¼¼ã€‚é€šè¿‡å¼•ç”¨å‘å‡½æ•°ä¼ å‚, å°†ä¸ä¼šå‘ç”Ÿæ‰€æœ‰æƒçš„è½¬ç§»ã€‚

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

æˆ‘ä»¬ç§°åˆ›å»ºä¸€ä¸ªå¼•ç”¨çš„è¡Œä¸ºä¸ºå€Ÿç”¨(borrowing)ã€‚

---

ä¸€ä¸ªå¯¹è±¡çš„å€¼æ˜¯ä¸èƒ½è¢«å…¶å¼•ç”¨ä¿®æ”¹çš„, å³ä½¿å®ƒè¢«å£°æ˜ä¸º `mut`:

```rust
fn main() {
    let mut s = String::from("hello");
    hi(&s);
    println!("s = \"{s}\"");
}

fn hi(s : &String) {
    s.clear();
    s.push_str("hi");
}
```

æŠ¥é”™:

```plaintext
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
warning: variable does not need to be mutable
 --> src/main.rs:2:9
  |
2 |     let mut s = String::from("hello");
  |         ----^
  |         |
  |         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

error[E0596]: cannot borrow `*s` as mutable, as it is behind a `&` reference
 --> src/main.rs:8:5
  |
7 | fn hi(s : &String) {
  |           ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     s.clear();
  |     ^^^^^^^^^ `s` is a `&` reference, so the data it refers to cannot be borrowed as mutable

error[E0596]: cannot borrow `*s` as mutable, as it is behind a `&` reference
 --> src/main.rs:9:5
  |
7 | fn hi(s : &String) {
  |           ------- help: consider changing this to be a mutable reference: `&mut String`
8 |     s.clear();
9 |     s.push_str("hi");
  |     ^^^^^^^^^^^^^^^^ `s` is a `&` reference, so the data it refers to cannot be borrowed as mutable

For more information about this error, try `rustc --explain E0596`.
warning: `hello_cargo` (bin "hello_cargo") generated 1 warning
error: could not compile `hello_cargo` due to 2 previous errors; 1 warning emitted
```

è§£å†³æ–¹æ¡ˆæ˜¯å°†å‡½æ•°çš„å½¢å‚ä¹Ÿå£°æ˜ä¸º `mut`, å¹¶åœ¨ä¼ é€’å‚æ•°çš„å¼•ç”¨æ—¶ä¹ŸåŠ ä¸Š `mut`ã€‚æ­¤æ—¶è¿™ä¸ªå¼•ç”¨å°±å˜æˆäº†å¯å˜å¼•ç”¨ã€‚

```rust
fn main() {
    let mut s = String::from("hello");
    hi(&mut s);
    println!("s = \"{s}\"");
}

fn hi(s : &mut String) {
    s.clear();
    s.push_str("hi");
}
```

å¯å˜å¼•ç”¨æœ‰ä¸€ä¸ªå¾ˆå¤§çš„é™åˆ¶:å¦‚æœä½ æœ‰ä¸€ä¸ªå¯¹è¯¥å˜é‡çš„å¯å˜å¼•ç”¨ï¼Œä½ å°±ä¸èƒ½å†åˆ›å»ºå¯¹è¯¥å˜é‡çš„å¼•ç”¨ã€‚è¿™äº›å°è¯•åˆ›å»ºä¸¤ä¸ª s çš„å¯å˜å¼•ç”¨çš„ä»£ç ä¼šå¤±è´¥ã€‚

```rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s;
    println!("{}, {}", r1, r2);
}
```

```plaintext
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --> src/main.rs:4:14
  |
3 |     let r1 = &mut s;
  |              ------ first mutable borrow occurs here
4 |     let r2 = &mut s;
  |              ^^^^^^ second mutable borrow occurs here
5 |     println!("{}, {}", r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
```

ä¸è¿‡ä¸å¯å˜çš„å¼•ç”¨ä¸å—è¿™ä¸ªé™åˆ¶çš„å½±å“ã€‚æˆ‘ä»¬å¯ä»¥åŒæ—¶æŒæœ‰ä¸€ä¸ªå˜é‡çš„å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚

---

ä½†æ˜¯, å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨ä¸èƒ½åŒæ—¶å­˜åœ¨ã€‚ä¸è¿‡è¿™ä¸ª"ä¸èƒ½å­˜åœ¨"çš„è¡¨ç°å½¢å¼æ¯”è¾ƒç‰¹æ®Šã€‚

é¦–å…ˆæˆ‘ä»¬éªŒè¯å¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨ç¡®å®ä¸èƒ½åŒæ—¶å­˜åœ¨:

```rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &s;
    println!("{}", r1);
    println!("{}", r2);
}
```

```plaintext
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
error[E0502]: cannot borrow `s` as immutable because it is also borrowed as mutable
 --> src/main.rs:4:14
  |
3 |     let r1 = &mut s;
  |              ------ mutable borrow occurs here
4 |     let r2 = &s;
  |              ^^ immutable borrow occurs here
5 |     println!("{}", r1);
  |                    -- mutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `hello_cargo` due to previous error
```

å¯ä»¥çœ‹åˆ°, ç¡®å®äº§ç”Ÿäº†æŠ¥é”™ã€‚
ä»æŠ¥é”™å¯ä»¥çœ‹åˆ°, ä¸å¯å˜å¼•ç”¨ `r2`çš„å£°æ˜å¿…é¡»è¢«æ”¾ç½®åœ¨å¯å˜å¼•ç”¨ `r1`çš„æœ€åä¸€æ¬¡ä½¿ç”¨ä¹‹åã€‚

å¦‚æœæˆ‘ä»¬äº¤æ¢ `let r2 = &s` å’Œ `prinln!("{}", r1);` çš„é¡ºåº, å°±èƒ½å¤Ÿç¼–è¯‘äº†:

```rust
fn main() {
    let mut s = String::from("hello");
    let r1 = &mut s;
    println!("{}", r1);
    let r2 = &s;
    println!("{}", r2);
}
```

```plaintext
$ cargo run
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/hello_cargo`
hello
hello
```

è¿™æ˜¯å› ä¸ºrustç¼–è¯‘å™¨æ‹¥æœ‰èƒ½å¤Ÿåœ¨ä½œç”¨åŸŸç»“æŸä¹‹å‰åˆ¤æ–­ä¸å†ä½¿ç”¨çš„å¼•ç”¨çš„èƒ½åŠ›, è¿™è¢«ç§°ä¸ºéè¯æ³•ä½œç”¨åŸŸç”Ÿå‘½å‘¨æœŸ(Nonâˆ’Lexical Lifetimesï¼Œç®€ç§° NLL)ã€‚

---

Rustçš„é™æ€æ£€æŸ¥ä¸å…è®¸æ‚¬å‚å¼•ç”¨(dangling reference)çš„åˆ›å»ºã€‚

æ¯”å¦‚ä¸‹ä¾‹çš„ç¼–è¯‘ä¼šæŠ¥é”™:

```rust
fn main() {
    let r = dangle();
    println!("{r}");
}

fn dangle() -> &String {
    let s = String::from("Hello!");
    &s
}
```

```plaintext
$ cargo run
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
error[E0106]: missing lifetime specifier
 --> src/main.rs:6:16
  |
6 | fn dangle() -> &String {
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
6 | fn dangle() -> &'static String {
  |                 +++++++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `hello_cargo` due to previous error
```

ä½†è¿™ä¸ªä¸ä¼š:

```rust
fn main() {
    let s = String::from("Hello!");
    let r = dangle(&s);
    println!("{r}");
}

fn dangle(s : &String) -> &String {
    &s
}
```

è¿™ä¸ªä¹Ÿä¸ä¼š:

```rust
fn main() {
    let s = dangle();
    println!("{s}");
}

fn dangle() -> String {
    String::from("Hello!")
}
```

---

æ€»ç»“:

+ åœ¨ä»»æ„ç»™å®šæ—¶é—´ï¼Œè¦ä¹ˆåªèƒ½æœ‰ä¸€ä¸ªå¯å˜å¼•ç”¨ï¼Œè¦ä¹ˆåªèƒ½æœ‰å¤šä¸ªä¸å¯å˜å¼•ç”¨ã€‚
+ å¼•ç”¨å¿…é¡»æ€»æ˜¯æœ‰æ•ˆçš„ã€‚
