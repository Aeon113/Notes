# 2022-12-12

### Slice

slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。

和C++中的range一样, slice也是一个左闭右开区间。

例如字符串slice(string slice)是string中一部分值的引用。例如:

```rust
fn main() {
	let s = String::from("hello world");
	let hello = &s[0..5];
	let world = &s[6..11];
}
```

string slice的类型是 `&str`。比如如果我们需要实现一个查找字符串中的第一个单词的功能, 可以这样实现:

```rust
use std::io;
fn main() {
    let mut s = String::new();
    println!("Enter a line");
    io::stdin().read_line(&mut s).expect("Cannot read line!");

    let sl = first_word(&s);
    println!("First word: {}", sl);
}

fn first_word(s :&String) -> &str {
    let mut head_trimed = false;
    let mut begin : usize = 0;
    let mut end : usize = 0;
    for (i, &c) in s.as_bytes().iter().enumerate() {
        if c == b' ' || c == b'\t' {
            if head_trimed {
                end = i;
                break;
            }
            begin = i;
            continue;
        }
        head_trimed = true;
    }

    &s[begin..end]
}
```

然后, 为String创建string slice也即意味着对String创建了一个immutable reference。因此, 如果我们编写下述代码, 编译器会报错:

```rust
use std::io;
fn main() {
    let mut s = String::new();
    println!("Enter a line");
    io::stdin().read_line(&mut s).expect("Cannot read line!");

    let st = first_word(&s);
    s.clear();
    println!("First word: {}", st);
}

fn first_word(s :&String) -> &str {
    let mut head_trimed = false;
    let mut begin : usize = 0;
    let mut end : usize = 0;
    for (i, &c) in s.as_bytes().iter().enumerate() {
        if c == b' ' || c == b'\t' {
            if head_trimed {
                end = i;
                break;
            }
            begin = i;
            continue;
        }
        head_trimed = true;
    }

    &s[begin..end]
}
```

```plaintext
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --> src/main.rs:8:5
  |
7 |     let st = first_word(&s);
  |                         -- immutable borrow occurs here
8 |     s.clear();
  |     ^^^^^^^^^ mutable borrow occurs here
9 |     println!("First word: {}", st);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `hello_cargo` due to previous error
```

---

我们所申明的raw字符串的类型也是 `&str`。

```rust
let s = "Hello, world!";
```

这里的 `s`就是 `&str`类型。它指向一段不可变的字符串。

对于 `&`和 `*`的2个比较好的解释答案(在这个页面中的2个得分最高的答案): [syntax - What do the ampersand &#39;&amp;&#39; and star &#39;*&#39; symbols mean in Rust? - Stack Overflow](https://stackoverflow.com/questions/36335342/what-do-the-ampersand-and-star-symbols-mean-in-rust)

可以用这种方式获取一个 `String`内的所有字符的 `&str`:

```rust
let s = String::from("hahahaha");
let sl = &s[..]; // String::from(sl) == s
```

---

其它类型, 例如数组等, 都也可以拥有slice:

```rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
assert_eq!(slice, &[2, 3]);
assert_eq!(*slice, [2, 3]);
```

---

### 结构体

以下示例构造、访问一个结构体。例中的结构体定义在一个函数内, 实际上其通常被定义在函数外。

```rust
fn main() {
    struct User {
        active: bool,
        username: String,
        email: String,
        sign_in_count: u64
    }

    let mut user1 = User {
        email: String::from("aabbcc@outlook.com"),
        username: String::from("aabbcc"),
        active: true,
        sign_in_count: 1
    };

    user1.sign_in_count = 2;

    println!("user1: email: {}, username: {}, active: {}, sign_in_count: {}", user1.email, user1.username, user1.active, user1.sign_in_count);
}
```

注意和C++不同。C++允许将class/struct内的部分member variable声明为 `mutable`, 但 `rust`不允许将某个 `field`标记为 `mut`。如果需要修改一个struct实例的某个field, 需要将整个实例声明为 `mut`。

一旦定义了结构体后，为了使用它，通过为每个字段指定具体值来创建这个结构体的 实例。创建一个实例需要以结构体的名字开头，接着在大括号中使用 key: value 键-值对的形式提供字段，其中 key 是字段的名字，value 是需要存储在字段中的数据值。实例中字段的顺序不需要和它们在结构体中声明的顺序一致。换句话说，结构体的定义就像一个类型的通用模板，而实例则会在这个模板中放入特定数据来创建这个类型的值。

---

字符串的构造还有一种简写语法。如果用于初始化参数的变量名和参数名完全相同, 就可以省略参数名和冒号, 像下面这样:

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -> User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from("someone@example.com"),
        String::from("someusername123"),
    );
}
```

这里我们创建了一个新的 User 结构体实例，它有一个叫做 email 的字段。我们想要将 email 字段的值设置为 build_user 函数 email 参数的值。因为 email 字段与 email 参数有着相同的名称，则只需编写email 而不是 email: email。

---

使用一个结构体创建另一个结构体, 我们可以这样写:

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // --snip--

    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

还有一种写法, 是这样:

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // --snip--

    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1 // 这里代表user2中所有fields, 除了上方的email外, 均从user1复制
    };
}
```
