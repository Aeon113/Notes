# 2023-01-06

指针(pointer)是一个包含内存地址的变量的通用概念。这个地址引用，或 "指向"(points at)一些其他数据。Rust 中最常见的指针是第四章介绍的引用(reference)。引用以 & 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也没有任何额外开销，所以应用得最多。

另一方面，智能指针(smart pointers)是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。智能指针的概念并不为 Rust 所独有;其起源于 C++ 并存在于其他语言中。Rust 标准库中不同的智能指针提供了多于引用的额外功能。本章将会探索的一个例子便是引用计数(reference counting) 智能指针类型，其允许数据有多个所有者。引用计数智能指针记录总共有多少个所有者，并当没有任何所有者时负责清理数据。

在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针;相反，在大部分情况下，智能指针 拥有他们指向的数据。

> 实际上本书中已经出现过一些智能指针，比如第八章的 `String` 和 `Vec<T>`，虽然当时我们并不这么称呼 它们。这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们。它们也带有元数据(比如他 们的容量)和额外的功能或保证(String 的数据总是有效的 UTF-8 编码)。
>
> 智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特性在于其实现了 `Deref` 和 `Drop` trait。`Deref` trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用、又用于智 能指针的代码。`Drop` trait 允许我们自定义当智能指针离开作用域时运行的代码。
>
> 考虑到智能指针是一个在 Rust 经常被使用的通用设计模式，本章并不会覆盖所有现存的智能指针。很多库都有自己的智能指针而你也可以编写属于你自己的智能指针。这里将会讲到的是来自标准库中最常用的一些:
>
> + `Box<T>`，用于在堆上分配值
> + `Rc<T>`，一个引用计数类型，其数据可以有多个所有者
> + `Ref<T>` 和 `RefMut<T>`，通过 `RefCell<T>` 访问。(`RefCell<T>` 是一个在运行时而不是在编译时执行 借用规则的类型)。
>   另外我们会涉及内部可变性(interior mutability)模式，这是不可变类型暴露出改变其内部值的 API。 我们也会讨论引用循环(reference cycles)会如何泄漏内存，以及如何避免。

---

> 最简单直接的智能指针是 box，其类型是 `Box<T>`。box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。如果你想回顾一下栈与堆的区别请参考第四章。
>
> 除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用 如下场景:
>
> + 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
> + 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
> + 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候
>
> 我们会在 ”box 允许创建递归类型” 部分展示第一种场景。在第二种情况中，转移大量数据的所有权可能 会花费很长的时间，因为数据在栈上进行了拷贝。为了改善这种情况下的性能，可以通过 box 将这些数据储存在堆上。接着，只有少量的指针数据在栈上被拷贝。第三种情况被称为 trait 对象(trait object)， 第十七章刚好有一整个部分 ” 顾及不同类型值的 trait 对象” 专门讲解这个主题。所以这里所学的内容会 在第十七章再次用上!

---

下例展示了如何使用box在堆上存储一个i32:

```rust
fn main() {
  let b = Box::new(5);
  println!("b = {}", b);
}
```

```plaintext
$ cargo run
   Compiling hello_cargo v0.1.0 (/Users/user/projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.15s
     Running `/Users/user/projects/target/debug/hello_cargo`
b = 5
```

---

## 将 box 用于递归类型定义

这点和C/C++是一样的, 在为一个类型定义指针时, 并不需要知道知道其所指向的类型的完整定义。只要在提领 `dereference`指针时知道就行了。

比如下例, 是无法通过编译的:

```rust
enum List {
    Cons(i32, List),
    Nil,
}
```

而这样就可以:

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}
```

box 只提供了间接存储和堆分配; 他们并没有任何其他特殊的功能，比如我们将会见到的其他智能指针。它们也没有这些特殊功能带来的性能损失，所以他们可以用于像 cons list 这样间接存储是唯一所需功能的场景。我们还将在第十七章看到 box 的更多应用场景。

`Box<T>` 类型是一个智能指针，因为它实现了 `Deref` trait，它允许 `Box<T>` 值被当作引用对待。当 `Box<T>` 值离开作用域时，由于 `Box<T>` 类型 Drop trait 的实现，box 所指向的堆数据也会被清除。

---

TODO 15.2
