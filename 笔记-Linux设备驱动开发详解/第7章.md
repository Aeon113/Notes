# 第7章
## 7.1
2.6版本后的内核默认不允许中断嵌套。   
访问共享资源的代码区域成为`临界区`(Critical Sections), 临界区需要被以某种互斥机制加以保护。中断屏蔽，原子操作，自旋锁，信号量，互斥体等是Linux设备驱动中可采用的互斥途径。  
***
## 7.2  
gcc中使用`barrier()`宏来部分阻止编译器对语句做乱序优化：一个最小代码快中`barier()`前的语句一定在`barrier()`后的语句前执行。   
``` c
#define barrier() __asm__ __volatile__ ("": : :"memory")
```
ARM提供了如下三种屏障指令，用于同步多核间的行为:   
| 指令              | 作用                                                 |
|:-----------------|-----------------------------------------------------:|
| DMB (数据内存屏障) | 在 DMB 之后的显式内存访问执行前,保证所有在 DMB 指令之前的内存访问完成 |
| DSB (数据同步屏障) | 等待所有在 DSB 指令之前的指令完成(位于此指令前的所有显式内存访问均完成,位于此指令前的所有缓存、跳转预测和 TLB 维护操作全部完成) |
| ISB (指令同步屏障) |  Flush 流水线,使得所有 ISB 之后执行的指令都是从缓存或内存中获得的 |

ARM Linux的自旋锁、互斥锁等互斥逻辑需要使用上述逻辑。下列代码描述了一个互斥逻辑: 
``` asm
LOCKED EQU 1
UNLOCKED EQU 0

lock_mutex
    ;互斥量是否锁定?
    LDREX r1, [r0] ; 检查是否锁定
    CMP r1, #LOCKED ; 和"locked" 比较
    WFEEQ ; 互斥量已经锁定,进入休眠
    BEQ lock_mutex ; 被唤醒,重新检查互斥量是否锁定
    ; 尝试锁定互斥量
    MOV r1, #LOCKED
    STREX r2, r1, [r0] ; 尝试锁定
    CMP r2, #0x0 ; 检查 STR 指令是否完成
    BNE lock_mutex ; 如果失败,重试
    DMB ; 进入被保护的资源前需要隔离,保证互斥量已经被更新
    BX lr


unlock_mutex
    DMB ; 保证资源的访问已经结束
    MOV r1, #UNLOCKED ; 向锁定域写"unlocked"
    STR r1, [r0]

    DSB ; 保证在 CPU 唤醒前完成互斥量状态更新
    SEV ; 像其他 CPU 发送事件,唤醒任何等待事件的 CPU

    BX lr
```
在 Linux 内核中,定义了读写屏障 `mb ()`、读屏障 `rmb ()`、写屏障 `wmb ()`、以及作用于寄存器读写的 `__iormb ()`、 `__iowmb ()`这样的屏障 API 。读写寄存器的 `readl_relaxed ()`和 `readl ()`、 `writel_relaxed ()`和`writel ()` API 的区别就体现在有无屏障方面。
``` c
#define readb(c) ({ u8 __v = readb_relaxed(c); __iormb(); __v; })
#define readw(c) ({ u16 __v = readw_relaxed(c); __iormb(); __v; })
#define readl(c) ({ u32 __v = readl_relaxed(c); __iormb(); __v; })
#define writeb(v,c) ({ __iowmb(); writeb_relaxed(v,c); })
#define writew(v,c) ({ __iowmb(); writew_relaxed(v,c); })
#define writel(v,c) ({ __iowmb(); writel_relaxed(v,c); })
```
比如我们通过 `writel_relaxed ()`写完 DMA 的开始地址、结束地址、大小之后,我们一定要调用 `writel ()`来启动DMA 。
``` c
writel_relaxed(DMA_SRC_REG, src_addr);
writel_relaxed(DMA_DST_REG, dst_addr);
writel_relaxed(DMA_SIZE_REG, size);
writel (DMA_ENABLE, 1);
```
***
## 7.3 中断屏蔽
为避免当前CPU核上的其他线程抢断当前任务，可以使用中断屏蔽来使CPU临时停止响应中断。由于中断在操作系统中的重要性，要使中断屏蔽的时间尽可能的短。   
在多核架构中，这种方式只能禁止当前CPU核响应中断，不能禁止其它CPU核响应。   
屏蔽中断的方法为:   
``` c
local_irq_disable(); // 关中断
/* ... */
/* critical_section */ // 临界区
/* ... */
local_irq_enable(); // 开中断
```
在ARM上，这两个函数会设置CPSR的I位。   
除了`local_irq_disable()`外，还可以使用`local_irq_save(flags)`来禁止中断响应。与前者不同的是，其在屏蔽中断的时候还会保存目前CPU的中断位信息，其使用`local_irq_save(flags)`来进行相反的操作。   
如果只想禁止中断的底半部，可以使用`local_bh_disable()`，由此屏蔽的中断应使用`local_bh_enable()`来恢复。   
***
## 7.4 原子操作
原子操作可以保证对一个整形数据的修改是排他性的。Linux提供了一系列函数来实现内核中的原子操作，其又分为两类，分别对位和整形变量进行原子操作。对于ARM，其主要使用`LDREX`和`STREX`指令实现。   
例如`atomic_inc()`底层会调用的`atomic_add()`:
``` c
// 此为ARM代码:

static inline void atomic_add(int i, atomic_t *v)
{
    unsigned long tmp;
    int result;
    prefetchw(&v->counter);

    __asm__ __volatile__("@ atomic_add\n"
        "1: ldrex %0, [%3]\n"  
        " add %0, %0, %4\n"
        " strex %1, %0, [%3]\n" 
        " teq %1, #0\n"
        " bne 1b"
        : "=&r" (result), "=&r" (tmp), "+Qo" (v->counter)
        : "r" (&v->counter), "Ir" (i)
        : "cc");
}
```
   
关于`LDREX`和`STREX`:
``` asm
LDREX{cond} Rt, [Rn {, #offset}]
STREX{cond} Rd, Rt, [Rn {, #offset}]
```
其中：
| 参数       | 意义               |
|:----------|------------------:|
|  cond    |  条件代码            |
|  Rd   | 是存放返回状态的目标寄存器  |
|  Rt   |    是要加载或存储的寄存器  |
|  Rt2   |  为进行双字加载或存储时要用到的第二个寄存器  |
|  Rn   |  是内存地址所基于的寄存器  |
|  offset   |  为应用于 Rn 中的值的可选偏移量。offset 只可用于 Thumb-2 指令中。 如果省略 offset，则认为偏移量为 0  |
LDREX 可从内存加载数据。
+   如果物理地址有共享 TLB 属性，则 LDREX 会将该物理地址标记为由当前处理器独占访问，并且会清除该处理器对其他任何物理地址的任何独占访问标记。
+   否则，会标记：执行处理器已经标记了一个物理地址，但访问尚未完毕。   

STREX 可在一定条件下向内存存储数据。 条件具体如下：
+   如果物理地址没有共享 TLB 属性，且执行处理器有一个已标记但尚未访问完毕的物理地址，那么将会进行存储，清除该标记，并在 Rd 中返回值 0。
+   如果物理地址没有共享 TLB 属性，且执行处理器也没有已标记但尚未访问完毕的物理地址，那么将不会进行存储，而会在 Rd 中返回值 1。
+   如果物理地址有共享 TLB 属性，且已被标记为由执行处理器独占访问，那么将进行存储，清除该标记，并在 Rd 中返回值 0。
+   如果物理地址有共享 TLB 属性，但没有标记为由执行处理器独占访问，那么不会进行存储，且会在 Rd 中返回值 1。   

限制
+   r15 不可用于 Rd、Rt、Rt2 或 Rn 中的任何一个。
+   对于 STREX，Rd 一定不能与 Rt、Rt2 或 Rn 为同一寄存器。   
+   对于 ARM 指令：
    +   Rt 必须是一个编号为偶数的寄存器，且不能为 r14
    +   Rt2 必须为 R(t+1)
    +   不允许使用 offset。
+   对于 Thumb 指令：
    +   r13 不可用于 Rd、Rt 或 Rt2 中的任何一个
    +   对于 LDREXD，Rt 和 Rt2 不可为同一个寄存器
    +   offset 的值可为 0-1020 范围内 4 的任何倍数。   

用法
+   利用 LDREX 和 STREX 可在多个处理器和共享内存系统之前实现进程间通信。
+   出于性能方面的考虑，请将相应 LDREX 指令和 STREX 指令间的指令数控制到最少。   

Note
+   STREX 指令中所用的地址必须要与近期执行次数最多的 LDREX 指令所用的地址相同。 如果使用不同的地址，则 STREX 指令的执行结果将不可预知。   

体系结构
+   ARM LDREX 和 STREX 可用于 ARMv6 及更高版本中。
+   ARM LDREXB、LDREXH、LDREXD、STREXB、STREXD 和 STREXH 可用于 ARMv6K 及更高版本中。
+   所有这些 32 位 Thumb 指令均可用于 ARMv6T2 及更高版本，但 LDREXD 和 STREXD 在 ARMv7-M 架构中不可用。
+   这些指令均无 16 位版本。
***
## 7.4.1 整型原子操作
1. 设置原子变量的值
    ``` c
    void atomic_set(atomic_t *v, int i); /* 设置原子变量的值为 i */
    atomic_t v = ATOMIC_INIT(0); /* 定义原子变量 v 并初始化为 0 */
    ```
2. 获取原子变量的值
    ``` c
    atomic_read(atomic_t *v); /* 返回原子变量的值 */
    ```
3. 原子变量加 / 减
    ``` c
    void atomic_add(int i, atomic_t *v); /* 原子变量增加 i */
    void atomic_sub(int i, atomic_t *v); /* 原子变量减少 i */
    ```
4. 原子变量自增 / 自减
    ``` c
    void atomic_inc(atomic_t *v); /* 原子变量增加 1 */
    void atomic_dec(atomic_t *v); /* 原子变量减少 1 */
    ```
5. 操作并测试
    ``` c
    int atomic_inc_and_test(atomic_t *v);
    int atomic_dec_and_test(atomic_t *v);
    int atomic_sub_and_test(int i, atomic_t *v);
    ```   
    上述操作对原子变量执行自增、自减和减操作后(注意没有加),测试其是否为 0 ,为 0 返回 true ,否则返回false 。   
6. 操作并返回
    ``` c
    int atomic_add_return(int i, atomic_t *v);
    int atomic_sub_return(int i, atomic_t *v);
    int atomic_inc_return(atomic_t *v);
    int atomic_dec_return(atomic_t *v);
    ```   
    上述操作对原子变量进行加 / 减和自增 / 自减操作,并返回新的值。
***
## 7.4.2 位原子操作
1. 设置位
    ``` c
    void set_bit(nr, void *addr);
    ```
    上述操作设置 addr 地址的第 nr 位,所谓设置位即是将位写为 1 。   
2. 清除位
    ``` c
    void clear_bit(nr, void *addr);
    ```
    上述操作清除 addr 地址的第 nr 位,所谓清除位即是将位写为 0 。   
3. 改变位
    ``` c
    void change_bit(nr, void *addr);
    ```
    上述操作对 addr 地址的第 nr 位进行反置。   
4. 测试位
    ``` c
    test_bit(nr, void *addr);
    ```   
    上述操作返回 addr 地址的第 nr 位。
5. 测试并操作位
    ``` c
    int test_and_set_bit(nr, void *addr);
    int test_and_clear_bit(nr, void *addr);
    int test_and_change_bit(nr, void *addr);
    ```
    上述 `test_and_xxx_bit ( nr , void*addr )`操作等同于执行 `test_bit ( nr , void*addr )` 后再执行 `xxx_bit ( nr , void*addr )`。   

代码清单 7.2 给出了原子变量的使用例子,它使得设备最多只能被一个进程打开。
``` c
// 代码清单 7.2: 使用原子变量使设备只能被一个进程打开
static atomic_t xxx_available = ATOMIC_INIT(1); /* 定义原子变量 */

static int xxx_open(struct inode *inode, struct file *filp)
{
    ...
    if (!atomic_dec_and_test(&xxx_available)) {
        atomic_inc(&xxx_available);
        return - EBUSY;     /* 已经打开 */
    }
    ...
    return 0;   /* 成功 */
}

static int xxx_release(struct inode *inode, struct file *filp)
{
    atomic_inc(&xxx_available);      /* 释放设备 */
    return 0;
}
```
***
## 7.5.1 自旋锁的使用
1. 定义自旋锁
    ``` c
    spinlock_t lock;
    ```
2. 初始化自旋锁
    ``` c
    spin_lock_init(lock)
    ```
    该宏用于动态初始化自旋锁 lock 。
3. 获得自旋锁
    ``` c
    spin_lock(lock)
    ```
    该宏用于获得自旋锁 lock ,如果能够立即获得锁,它就马上返回,否则,它将在那里自旋,直到该自旋锁的保持者释放。
    ``` c
    spin_trylock(lock)
    ```
    该宏尝试获得自旋锁 lock ,如果能立即获得锁,它获得锁并返回 true ,否则立即返回 false ,实际上不再 “ 在原地打转 ” 。
4. 释放自旋锁
    ``` c
    spin_unlock(lock)
    ```   
    该宏释放自旋锁 lock ,它与 spin_trylock 或 spin_lock 配对使用。   

自旋锁一般这样使用:
``` c
/* 定义一个自旋锁 */
spinlock_t lock;
spin_lock_init(&lock);
spin_lock (&lock) ;     /* 获取自旋锁,保护临界区 */
.../* 临界区 */
spin_unlock (&lock) ; /* 解锁 */
```
自旋锁一般用于SMP或单核CPU但内核可被抢占的情况，对于单CPU且内核不支持抢占的系统，自旋锁自动退化为空操作。   
在单CPU且内核可被抢占的情况下，自旋锁持有期间内核不能被抢占。   
其实，在SMP平台上，持有自旋锁的CPUcore，其上的内核也不能被抢占，但其他core可以。   
尽管用了自旋锁可以保证临界区不受别的 CPU 和本 CPU 内的抢占进程打扰,但是得到锁的代码路径在执行临界区的时候,还可能受到中断和底半部( BH ,稍后的章节会介绍)的影响。为了防止这种影响,就需要用到自旋锁的衍生。   
`pin_lock ()` / `spin_unlock ()`是自旋锁机制的基础,它们和关中断 `local_irq_disable ()` / 开中断 `local_irq_enable ()`、关底半部 `local_bh_disable ()` / 开底半部`local_bh_enable ()`、关中断并保存状态字 `local_irq_save ()` / 开中断并恢复状态字 `local_irq_restore ()`结合就形成了整套自旋锁机制,关系如下:
```
spin_lock_irq() = spin_lock() + local_irq_disable()
spin_unlock_irq() = spin_unlock() + local_irq_enable()
spin_lock_irqsave() = spin_lock() + local_irq_save()
spin_unlock_irqrestore() = spin_unlock() + local_irq_restore()
spin_lock_bh() = spin_lock() + local_bh_disable()
spin_unlock_bh() = spin_unlock() + local_bh_enable()
```
`spin_lock_irq ()`、 `spin_lock_irqsave ()`、 `spin_lock_bh ()`类似函数会为自旋锁的使用系好 “ 安全带 ” 以避免突如其来的中断驶入对系统造成的伤害。   
驱动工程师应谨慎使用自旋锁,而且在使用中还要特别注意如下几个问题:   
1.  自旋锁实际上是忙等锁,当锁不可用时, CPU 一直循环执行 “ 测试并设置 ” 该锁直到可用而取得该锁, CPU 在等待自旋锁时不做任何有用的工作,仅仅是等待。因此,只有在占用锁的时间极短的情况下,使用自旋锁才是合理的。当临界区很大,或有共享设备的时候,需要较长时间占用锁,使用自旋锁会降低系统的性能。   
2.  自旋锁可能导致系统死锁。引发这个问题最常见的情况是递归使用一个自旋锁,即如果一个已经拥有某个自旋锁的 CPU 想第二次获得这个自旋锁,则该 CPU 将死锁。   
3.  在自旋锁锁定期间不能调用可能引起进程调度的函数。如果进程获得自旋锁之后再阻塞,如调用 `copy_from_user ()`、`copy_to_user ()`、 `kmalloc ()`和 `msleep ()`等函数,则可能导致内核的崩溃。   
4.  在单核情况下编程的时候,也应该认为自己的 CPU 是多核的,驱动特别强调跨平台的概念。比如,在单 CPU 的情况下,若中断和进程可能访问同一临界区,进程里调用 `spin_lock_irqsave ()`是安全的,在中断里其实不调用 `spin_lock ()`也没有问题,因为`spin_lock_irqsave ()`可以保证这个 CPU 的中断服务程序不可能执行。但是,若 CPU 变成多核, `spin_lock_irqsave ()`不能屏蔽另外一个核的中断,所以另外一个核就可能造成并发问题。因此,无论如何,我们在中断服务程序里也应该调用 `spin_lock ()`。
***
## 7.5.2 读写自旋锁
自旋锁不关心锁定的临界区究竟在进行什么操作,不管是读还是写,它都一视同仁。即便多个执行单元同时读取临界资源也会被锁住。实际上,对共享资源并发访问时,多个执行单元同时读取它是不会有问题的,自旋锁的衍生锁读写自旋锁( rwlock )可允许读的并发。读写自旋锁是一种比自旋锁粒度更小的锁机制,它保留了 “ 自旋 ” 的概念,但是在写操作方面,只能最多有 1 个写进程,在读操作方面,同时可以有多个读执行单元。当然,读和写也不能同时进行。   
读写自旋锁涉及的操作如下:   
1.  定义和初始化读写自旋锁
    ``` c
    rwlock_t my_rwlock;
    rwlock_init(&my_rwlock);  /* 动态初始化 */
    ```
2.  读锁定
    ``` c
    void read_lock(rwlock_t *lock);
    void read_lock_irqsave(rwlock_t *lock, unsigned long flags);
    void read_lock_irq(rwlock_t *lock);
    void read_lock_bh(rwlock_t *lock);
    ```
3. 读解锁
    ``` c
    void read_unlock(rwlock_t *lock);
    void read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
    void read_unlock_irq(rwlock_t *lock);
    void read_unlock_bh(rwlock_t *lock);
    ```   

在对共享资源进行读取之前,应该先调用读锁定函数,完成之后应调用读解锁函数。   
`read_lock_irqsave ()`、 `read_lock_irq ()`和 `read_lock_bh ()`也分别是 `read_lock ()`分别与 `local_irq_save ()`、`和 local_bh_disable ()`的组合,读解锁函数 `read_unlock_irqrestore ()`、 `read_unlock_irq ()`、`read_unlock_bh ()`的情况与此类似。   

4.  写锁定   
    ``` c
    void write_lock(rwlock_t *lock);
    void write_lock_irqsave(rwlock_t *lock, unsigned long flags);
    void write_lock_irq(rwlock_t *lock);
    void write_lock_bh(rwlock_t *lock);
    int write_trylock(rwlock_t *lock);
    ```   
5. 写解锁   
    ``` c
    void write_unlock(rwlock_t *lock);
    void write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);
    void write_unlock_irq(rwlock_t *lock);
    void write_unlock_bh(rwlock_t *lock);
    ```   

`write_lock_irqsave ()`、 `write_lock_irq ()`、 `write_lock_bh ()`分别是 `write_lock ()`与 `local_irq_save ()`、`local_irq_disable ()`和 `local_bh_disable ()`的组合,写解锁函数 `write_unlock_irqrestore ()`、`write_unlock_irq ()`、 `write_unlock_bh ()`的情况与此类似。   
在对共享资源进行写之前,应该先调用写锁定函数,完成之后应调用写解锁函数。和 `spin_trylock ()`一样, `write_trylock ()`也只是尝试获取读写自旋锁,不管成功失败,都会立即返回。    
读写自旋锁一般这样被使用:   
``` c
rwlock_t lock;                              /* 定义 rwlock */
rwlock_init(&lock);                         /* 初始化 rwlock */ 

/* 读时获取锁 */
read_lock(&lock);
...                                         /* 临界资源 */
read_unlock(&lock);

/* 写时获取锁 */
write_lock_irqsave(&lock, flags);
...                                         /* 临界资源 */
write_unlock_irqrestore(&lock, flags);
```
***
## 7.5.3 顺序锁
顺序锁( seqlock )是对读写锁的一种优化,若使用顺序锁,读执行单元不会被写执行单元阻塞,也就是说,读执行单元在写执行单元对被顺序锁保护的共享资源进行写操作时仍然可以继续读,而不必等待写执行单元完成写操作,写执行单元也不需要等待所有读执行单元完成读操作才去进行写操作。但是,写执行单元与写执行单元之间仍然是互斥的,即如果有写执行单元在进行写操作,其他写执行单元必须自旋在那里,直到写执行单元释放了顺序锁。    
对于顺序锁而言,尽管读写之间不互相排斥,但是如果读执行单元在读操作期间,写执行单元已经发生了写操作,那么,读执行单元必须重新读取数据,以便确保得到的数据是完整的。所以,在这种情况下,读端可能反复读多次同样的区域才能读到有效的数据。   
在 Linux 内核中,写执行单元涉及的顺序锁操作如下:   
1.  获得顺序锁
    ``` c
    void write_seqlock(seqlock_t *sl);
    int write_tryseqlock(seqlock_t *sl);
    write_seqlock_irqsave(lock, flags)
    write_seqlock_irq(lock)
    write_seqlock_bh(lock)
    ```   
    其中, 
    ``` 
    write_seqlock_irqsave() = loal_irq_save() + write_seqlock()
    write_seqlock_irq() = local_irq_disable() + write_seqlock()
    write_seqlock_bh() = local_bh_disable() + write_seqlock()
    ```   
2.  释放顺序锁
    ``` c
    void write_sequnlock(seqlock_t *sl);
    write_sequnlock_irqrestore(lock, flags)
    write_sequnlock_irq(lock)
    write_sequnlock_bh(lock)
    ```   
    其中,   
    ```
    write_sequnlock_irqrestore() = write_sequnlock() + local_irq_restore()
    write_sequnlock_irq() = write_sequnlock() + local_irq_enable()
    write_sequnlock_bh() = write_sequnlock() + local_bh_enable()
    ```   
    写执行单元使用顺序锁的模式如下:   
    ``` c
    write_seqlock(&seqlock_a);
    ... /* 写操作代码块 */
    write_sequnlock(&seqlock_a);
    ```   
    因此,对写执行单元而言,它的使用与自旋锁相同。   

读执行单元涉及的顺序锁操作如下:   
1.  读开始
    ``` c
    unsigned read_seqbegin(const seqlock_t *sl);
    read_seqbegin_irqsave(lock, flags)
    ```   
    读执行单元在对被顺序锁 s1 保护的共享资源进行访问前需要调用该函数,该函数返回顺序锁 s1 的当前顺序号。其中,   
    ```
    read_seqbegin_irqsave() = local_irq_save() + read_seqbegin()
    ```   
2.  重读
    ``` c    
    int read_seqretry(const seqlock_t *sl, unsigned iv);
    read_seqretry_irqrestore(lock, iv, flags)
    ```   
    读执行单元在访问完被顺序锁 s1 保护的共享资源后需要调用该函数来检查,在读访问期间是否有写操作。如果有写操作,读执行单元就需要重新进行读操作。其中,   
    ```
    read_seqretry_irqrestore() = read_seqretry() + local_irq_restore()
    ```   
    读执行单元使用顺序锁的模式如下:   
    ``` c
    do {
        seqnum = read_seqbegin(&seqlock_a);
        /* 读操作代码块 */
        ...
    } while (read_seqretry(&seqlock_a, seqnum));
    ```
***