# Coroutine Theory

_翻译自: [Coroutine Theory | Asymmetric Transfer](https://lewissbaker.github.io/2017/09/25/coroutine-theory)_

_这篇文章编写时, coroutine仍然处于TS阶段, 但其介绍的原理基本上和现行的C++ coroutine 标准一致_

在这篇文章中，我将描述函数和协程之间的差异，并提供一些关于它们支持的操作的理论。这篇文章的目标是介绍一些基础概念，这将有助于你思考C++协程。

这是一系列关于[C++ Coroutines TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4680.pdf)的文章的第一篇，这是一个新的语言特性，目前正在被纳入C++20语言标准中。

在这个系列中，我将介绍C++协程的底层机制如何工作，以及如何使用它们来构建有用的高级抽象，如[cppcoro](https://github.com/lewissbaker/cppcoro)库提供的那些。

在这篇文章中，我将描述函数和协程之间的差异，并提供一些关于它们支持的操作的理论。这篇文章的目标是介绍一些基础概念，这将有助于你思考C++协程。

## 协程就是函数，函数就是协程

_在无栈协程中, 协程不仅是一个运行期概念, 每一个无栈协程函数都是一个单独的协程; 举例来说, 如果运行期间有 协程函数 `A()` 调用 协程函数`B()`, 那么 `A()` 和 `B()` 分属2个不同的协程。_

协程是函数的一种泛化，它允许函数被挂起，然后在后面恢复。

我将详细解释这个意思，但在我做之前，我想先回顾一下一个"正常"的C++函数是如何工作的。

## "正常"的函数

一个正常的函数可以被认为有两个操作：**调用**和**返回**（注意，我在这里将"抛出异常"广义地归入**返回**操作）。

**调用**操作创建一个活动帧，挂起调用函数的执行，并将执行转移到被调用函数的开始。

**返回**操作将返回值传递给调用者，销毁活动帧，然后恢复调用者在调用函数之后的执行。

让我们更详细地分析这些语义...

### 活动帧

那么，什么是“活动帧”？

你可以将活动帧视为保存特定函数调用的当前状态的内存块。这个状态包括传递给函数的任何参数的值和任何局部变量的值。

对于“正常”的函数，活动帧还包括返回地址——即从函数返回时要转移执行的指令的地址——以及调用函数的调用的活动帧的地址。你可以将这些信息一起看作是描述函数调用的“续延”。也就是说，它们描述了在函数完成时哪个函数的哪个调用应该继续执行哪个点。

对于“正常”的函数，所有的活动帧都具有严格嵌套的生命周期。这种严格嵌套允许使用高效的内存分配数据结构来为每个函数调用分配和释放活动帧。这个数据结构通常被称为“堆栈”。

当在这个堆栈数据结构上分配一个活动帧时，它通常被称为“堆栈帧”。

这个堆栈数据结构是如此常见，以至于大多数（全部？）CPU架构都有一个专用的寄存器来保存指向堆栈顶部的指针（例如，在X64中，它是`rsp`寄存器）。

要为新的活动帧分配空间，只需将该寄存器的值增加帧大小。要释放活动帧的空间，只需将该寄存器的值减去帧大小。

### 调用操作

当一个函数调用另一个函数时，调用者必须首先准备好自己以进行挂起。

这个“挂起”步骤通常涉及将当前保存在CPU寄存器中的任何值保存到内存中，以便在函数恢复执行时可以恢复这些值。根据函数的调用约定，调用者和被调用者可能会协调谁保存这些寄存器值，但你仍然可以将它们视为**调用操作**的一部分。

调用者还将传递给被调用函数的任何参数的值存储到新的活动帧中，以便函数可以访问它们。

最后，调用者将调用者的恢复点的地址写入新的活动帧，并将执行转移到被调用函数的开始处。

在X86/X64架构中，这个最后的操作有自己的指令，即`call`指令，它将下一条指令的地址写入堆栈，将堆栈寄存器增加地址的大小，然后跳转到指令操作数中指定的地址。

### 返回操作

当一个函数通过`return`语句返回时，函数首先将返回值（如果有的话）存储在调用者可以访问的位置。这可以是调用者的活动帧或函数的活动帧（对于跨越两个活动帧之间边界的参数和返回值，这个区分可能有些模糊）。

然后，函数通过以下步骤销毁活动帧：

* 销毁返回点处的任何局部变量。
* 销毁参数对象。
* 释放活动帧使用的内存。

最后，函数通过以下步骤恢复调用者的执行：

* 通过将堆栈寄存器设置为指向调用者的活动帧，并恢复函数可能破坏的任何寄存器，来恢复调用者的活动帧。
* 跳转到在“调用”操作期间存储的调用者的恢复点。

请注意，与“调用”操作一样，一些调用约定可能会将“返回”操作的责任分散在调用者和被调用函数的指令之间。


## 协程

协程通过将函数的一些步骤从**调用**和**返回**操作中分离出来，将其泛化为三个额外的操作：**挂起**、**恢复**和**销毁**。

**挂起**操作在函数内部的特定挂起点挂起协程的执行，并将执行转移到调用者或恢复者，而不销毁活动帧。在协程执行被挂起后，挂起点处的任何对象仍然保持存活。

请注意，与函数的**返回**操作一样，协程只能在协程内部的明确定义的挂起点处挂起。

**恢复**操作在协程被挂起的点恢复执行。这会重新激活协程的活动帧。

**销毁**操作销毁活动帧，而不恢复协程的执行。在挂起点处的任何对象都将被销毁。用于存储活动帧的内存将被释放。

### 协程活动帧

由于协程可以在不销毁活动帧的情况下挂起，我们不能再保证活动帧的生命周期严格嵌套。这意味着活动帧通常不能使用堆栈数据结构进行分配，而可能需要存储在堆上。

C++协程TS中有一些规定，允许从调用者的活动帧中分配协程帧的内存，如果编译器可以证明协程的生命周期确实严格嵌套在调用者的生命周期内。这在许多情况下可以避免堆分配，前提是你有一个足够智能的编译器。

在协程中，活动帧的一些部分需要在协程挂起时保留，而另一些部分只需要在协程执行时保留。例如，作用域不跨越任何协程挂起点的变量的生命周期可以在堆栈上存储。

你可以将协程的活动帧逻辑上分为两部分：'协程帧 (堆帧)'和'栈帧'。

'协程帧'保存了协程在挂起时持续存在的部分活动帧，而'栈帧'部分仅在协程执行时存在，并在协程挂起并将执行转移到调用者/恢复者时释放。

### '挂起'操作

协程的**挂起**操作允许协程在函数执行过程中挂起，并将执行转移到调用者或恢复者。

在协程的函数体中，有一些被指定为挂起点的位置。在C++协程TS中，这些挂起点通过使用`co_await`或`co_yield`关键字来标识。

当协程达到其中一个挂起点时，它首先准备好协程以便后续的恢复操作：

* 确保寄存器中保存的任何值都写入协程帧
* 向协程帧写入一个值，指示协程被挂起的挂起点。这样，后续的**恢复**操作就知道在哪里恢复协程的执行，或者后续的**销毁**操作就知道哪些值在作用域内需要被销毁。

协程准备好恢复后，协程被认为是“挂起”的状态。

在将执行转移到调用者/恢复者之前，协程有机会执行一些额外的逻辑。这些额外的逻辑可以访问协程帧的句柄 (`coroutine_handle`)，以便稍后恢复或销毁它。

这种在协程进入“挂起”状态后执行逻辑的能力，使得协程可以在不需要同步的情况下安排恢复，否则如果协程在进入“挂起”状态之前安排恢复，可能需要进行同步，以防止协程的挂起和恢复竞争。我将在以后的文章中详细介绍这一点。

然后，协程可以选择立即恢复/继续执行协程，或者选择将执行转移到调用者/恢复者。

如果执行转移到调用者/恢复者，协程的活动帧的堆栈帧部分将被释放并从堆栈中弹出。

### '恢复' 操作

**恢复**操作可以在当前处于“挂起”状态的协程上执行。

当一个函数想要恢复一个协程时，它需要“跳”到函数中间的特定点执行。恢复者通过调用 已**挂起**的协程帧句柄 (`coroutine_handle`)的`void resume()`方法来识别恢复点并恢复协程的执行。

就像普通的函数调用一样，这次对`resume()`的调用将分配一个新的堆栈帧，并将调用者的返回地址存储在堆栈帧中，然后将执行转移到函数中。

然而，与其将执行转移到函数的开始处不同，它将执行转移到函数中上次挂起的位置。它通过从协程帧中加载恢复点并跳转到该点来实现。

当协程下次挂起或执行完成时，对`resume()`的调用将返回，并恢复调用函数的执行。

### '销毁'操作

**销毁**操作会销毁协程帧，而不会恢复协程的执行。

这个操作只能对已挂起的协程执行。

**销毁**操作与**恢复**操作非常相似，因为它重新激活协程的活动帧，包括分配一个新的堆栈帧并存储**销毁**操作的调用者的返回地址。

然而，**恢复**操作会将执行流转移到目标协程的上次的挂起点，**销毁**操作则转移到另一个的代码路径，该代码路径调用上次挂起时仍然存活的所有局部变量的析构函数, 随后释放协程帧使用的内存。

与**恢复**操作类似，**销毁**操作通过调用在相应的**挂起**操作期间提供的协程帧句柄 (`coroutine_handle`)的`void destroy()`方法来标识要销毁的特定活动帧。

### 协程的'调用'操作

协程的**调用**操作与普通函数的调用操作非常相似。实际上，从调用者的角度来看，没有任何区别。

然而，与普通函数只有在运行到完成时才返回给调用者不同，协程的调用操作在协程达到第一个挂起点时会恢复调用者的执行。

在对协程执行**调用**操作时，调用者分配一个新的堆栈帧，将参数写入堆栈帧，将返回地址写入堆栈帧，并将执行转移到协程。这与调用普通函数完全相同。

然后，协程首先在堆上分配一个协程帧，并将参数从堆栈帧复制/移动到协程帧中，以使参数的生命周期延伸到第一个挂起点之后 (如果参数是调用者的局部变量, 则参数可能在本协程在下次恢复前就被销毁, 这样协程恢复后参数将不能被访问)。

### 协程的'返回'操作

协程的**返回**操作与普通函数的返回操作有些不同。

当协程执行返回语句（根据 TS 规范需要使用`co_return`关键字而非`return`关键字）时，它会将返回值存储在某个地方（具体存储位置可以由协程自定义），然后销毁所有在作用域内的局部变量（但不包括参数）。

然后，协程有机会在将执行转移到调用者/恢复者之前执行一些额外的逻辑。

这些额外的逻辑可能执行一些操作来传递返回值，或者恢复等待结果的另一个协程。这完全可以自定义。

然后，协程可能执行**挂起**操作（保持协程帧的存活），或**销毁**操作（销毁协程帧）。

根据**挂起**/**销毁**操作的语义，执行将转移到调用者/恢复者，将活动帧的栈帧组件从栈中弹出。

需要注意的是，传递给**返回**操作的返回值与从**调用**操作返回的返回值不同，因为**返回**操作可能在调用者从初始的**调用**操作中恢复之后很长时间才执行。

## 一个示例

为了帮助理解这些概念，我想通过一个简单的示例来说明当协程被调用、挂起和稍后恢复时会发生什么。

假设我们有一个函数（或协程）`f()`，它调用了一个协程`x(int a)`。

在调用之前，我们的情况看起来有点像这样：

```
STACK                     REGISTERS               HEAP

                          +------+
+---------------+ <------ | rsp  |
|  f()          |         +------+
+---------------+
| ...           |
|               |
```

当调用 `x(42)` 时，首先会为 `x()` 创建一个栈帧，就像普通函数一样。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |
| ret= f()+0x123 |   |    +------+
+----------------+   +--- | rsp  |
|  f()           |        +------+
+----------------+
| ...            |
|                |
```

然后，一旦协程`x()`在堆上为协程帧分配了内存，并将参数值复制/移动到协程帧中，我们将得到类似下图的结果。请注意，编译器通常会将协程帧的地址存储在一个单独的寄存器中，而不是栈指针（例如，MSVC将其存储在`rbp`寄存器中）。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     +-----------+
+----------------+        | rbp  | ------+
| ...            |        +------+
|                |
```

如果协程 `x()` 调用另一个普通函数 `g()`，它会类似下面这样。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  g()           |   |
| ret= x()+0x45  |   |
+----------------+   |
|  x()           |   |
| coroframe      | --|-------------------+
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+             |  x()      |
+----------------+   +--- | rsp  |             | a =  42   |
|  f()           |        +------+             +-----------+
+----------------+        | rbp  |
| ...            |        +------+
|                |
```

当 `g()` 返回时，它将销毁自己的活动帧并恢复 `x()` 的活动帧。
假设我们将 `g()` 的返回值保存在一个名为 `b` 的局部变量中，该变量存储在协程帧中 (再次强调, 协程有的活动帧有2个部分, 一个堆帧(协程帧)和一个栈帧, 协程帧在协程的整个生命周期中都存在; 栈帧只有协程处于执行状态时才存在)。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |
| a  = 42        |   |                   +-->  +-----------+
| ret= f()+0x123 |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  f()           |        +------+       |     | b = 789   |
+----------------+        | rbp  | ------+     +-----------+
| ...            |        +------+
|                |
```

如果 `x()` 现在遇到一个挂起点并暂停执行而不销毁其活动帧，那么执行将返回到 `f()`。

这将导致 `x()` 的栈帧部分从栈中弹出，同时保留协程帧在堆上。当协程首次挂起时，将返回一个返回值给调用者。这个返回值通常保存了一个用于稍后恢复协程的协程帧的句柄(`coroutine_handle`)。

当 `x()` 暂停时，它还会将 `x()` 的恢复点的地址存储在协程帧中（称为 `RP`，即恢复点）。

```
STACK                     REGISTERS               HEAP
                                        +----> +-----------+
                          +------+      |      |  x()      |
+----------------+ <----- | rsp  |      |      | a =  42   |
|  f()           |        +------+      |      | b = 789   |
| handle     ----|---+    | rbp  |      |      | RP=x()+99 |
| ...            |   |    +------+      |      +-----------+
|                |   |                  |
|                |   +------------------+
```

这个句柄现在可以像普通值一样在函数之间传递。
在稍后的某个时间点，可能是从不同的调用栈甚至是在不同的线程上，某个函数（比如 `h()`）将决定恢复该协程的执行。
例如，当异步 I/O 操作完成时。

恢复协程的函数调用一个 `void resume(handle)` 函数来恢复协程的执行。对于调用者来说，这看起来就像调用一个带有单个参数的 `void` 返回类型的普通函数。

这将创建一个新的栈帧，记录调用者到 `resume()` 的返回地址，通过将协程帧的地址加载到寄存器中来激活协程帧，并在协程帧中存储的恢复点处恢复 `x()` 的执行。

```
STACK                     REGISTERS               HEAP
+----------------+ <-+
|  x()           |   |                   +-->  +-----------+
| ret= h()+0x87  |   |    +------+       |     |  x()      |
+----------------+   +--- | rsp  |       |     | a =  42   |
|  h()           |        +------+       |     | b = 789   |
| handle         |        | rbp  | ------+     +-----------+
+----------------+        +------+
| ...            |
|                |
```

## 总结

我已经描述了协程作为一个函数的一般化，它除了提供“普通”函数的“调用”和“返回”操作外，还有三个额外的操作 - “挂起”、“恢复”和“销毁”。

希望这为您提供了一些有用的思维框架，以便理解协程及其控制流。

在下一篇文章中，我将介绍 C++ 协程 TS 语言扩展的机制，并解释编译器如何将您编写的代码转换为协程。
