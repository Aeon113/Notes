## 2018-08-28
对sysfs中的节点的一次读写操作最多值允许传递一个PAGE_SIZE的数据
***
在sysfs中，所有数据均以`kobject`或`kset`者两种数据结构表示:   
+ `kobject`: 在 Linux 设备模型中最基本的对象，它的功能是提供引用计数和维持父子(parent)结构、平级(sibling)目录关系， `device`, `device_driver` 等各对象都是以 kobject 基础功能之上实现的:
``` c
struct kobject {
    const char              *name;
    struct list_head        entry;
    struct kobject          *parent;
    struct kset             *kset;
    struct kobj_type        *ktype;
    struct sysfs_dirent     *sd;
    struct kref             kref;
    unsigned int state_initialized:1;
    unsigned int state_in_sysfs:1;
    unsigned int state_add_uevent_sent:1;
    unsigned int state_remove_uevent_sent:1;
};
```
其中 struct kref 内含一个 atomic_t 类型用于引用计数， parent 是单个指向父节点的指针， entry 用于父 kset 以链表头结构将 kobject 结构维护成双向链表；

+ `kset`: kset: 它用来对同类型对象提供一个包装集合，在内核数据结构上它也是由内嵌一个 `kboject` 实现，因而它同时也是一个 `kobject` (面向对象 OOP 概念中的继承关系) ，具有 `kobject` 的全部功能；
``` c
struct kset {
        struct list_head list;
        spinlock_t list_lock;
        struct kobject kobj;
        struct kset_uevent_ops *uevent_ops;
};
```
其中的 struct list_head list 用于将集合中的 kobject 按 struct list_head entry 维护成双向链表；
***
Cannot set Attribute Permissions to 0666 in sysfs:   
在新内核的kernel.h中，有:
``` c
#define VERIFY_OCTAL_PERMISSIONS(perms)                      
     ...
     /* OTHER_WRITABLE?  Generally considered a bad idea. */ \
     BUILD_BUG_ON_ZERO((perms) & 2) + \
 ...
 ```
因此 ，不能使用`__ATTR`等宏来为`other`用户设置`write`权限，只能手动设置:
``` c
attr.mode = 0666;
```
***
Linux sysfs中，属性分为两种:普通的attribute和二进制attribute，如下：
``` c
/* include/linux/sysfs.h, line 26 */
struct attribute {
    const char *name;
     umode_t         mode;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
    bool ignore_lockdep:1;
    struct lock_class_key   *key;
    struct lock_class_key   skey;
#endif
};
  
/* include/linux/sysfs.h, line 100 */
struct bin_attribute {
    struct attribute    attr;
    size_t          size;
    void *private;
    ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *,
                    char *, loff_t, size_t);
    ssize_t (*write)(struct file *,struct kobject *, struct bin_attribute *,
                    char *, loff_t, size_t);
    int (*mmap)(struct file *, struct kobject *, struct bin_attribute *attr,
                    struct vm_area_struct *vma);
};
```
struct attribute为普通的attribute，使用该attribute生成的sysfs文件，只能用字符串的形式读写。而struct bin_attribute在struct attribute的基础上，增加了read、write等函数，因此它所生成的sysfs文件可以用任何方式读写。
***
## 2018-09-03
Note that input core keeps track of number of users for the device and makes sure that dev->open() is called only when the first user connects to the device and that dev->close() is called when the very last user disconnects. Calls to both callbacks are serialized.
***
input子系统的abs设备，可以设置坐标最大值、最小值和一些其他参数:
``` c
button_dev.absmin[ABS_X] = 0;
button_dev.absmax[ABS_X] = 255;
button_dev.absfuzz[ABS_X] = 4;
button_dev.absflat[ABS_X] = 8;
```
上述四行代码也等价于如下代码：
``` c
input_set_abs_params(button_dev, ABS_X, 0, 255, 4, 8);
```
`absfuzz`为偏移噪声，`absflat`设置了一个坐标原点周围的区域，在此区域内的abs值将被视作0。这两个参数在为手柄编写驱动时较常见。
***
For input subsystem, the `input_dev::name` (`const char *`) should be set before registering the input device by the input device driver. It should be a user-friendly string, list "Generic button device". If it is available for x11, it would be listed in `xinput list`.
***
`input_dev::id` (`struct input_id`) contains the bus ID (PCI, USB, ...), vendor ID and device ID of the device. The vendor and device ids are defined in `pci_ids.h`, `usb_ids.h` and similar include files. These fields should be set by the input device driver before registering it.   
The `idtype` field can be used for specific information for the input device driver.  
The `id` and `name` fields can be passed to userland via the `evdev` interface   
***
The `keycode`, `keycodemax`, `keycodesize` fields   
These three fields should be used by input devices that have dense keymaps. The keycode is an array used to map from scancodes to input system keycodes. The keycode max should contain the size of the array and keycodesize the size of each entry in it (in bytes).   
Userspace can query and alter current scancode to keycode mappings using EVIOCGKEYCODE and EVIOCSKEYCODE ioctls on corresponding evdev interface. When a device has all 3 aforementioned fields filled in, the driver may rely on kernel’s default implementation of setting and querying keycode mappings.   
***
`getkeycode()` and `setkeycode()` callbacks allow drivers to override default `keycode`/`keycodesize`/`keycodemax` mapping mechanism provided by input core and implement sparse keycode maps.
***
Auto keyrepeat is handled by the `input.c` module. Hardware autorepeat is not used, because it’s not present in many devices and even where it is present, it is broken sometimes (at keyboards: Toshiba notebooks). To enable autorepeat for your device, just set `EV_REP` in `dev->evbit`. All will be handled by the input system.
***
There are two other event types:   
+   EV_LED - used for the keyboard LEDs.
+   EV_SND - used for keyboard beeps.   
They are very similar to for example key events, but they go in the other direction - from the system to the input device driver. If your input device driver can handle these events, it has to set the respective bits in evbit, and also the callback routine:
``` c
button_dev->event = button_event;

int button_event(struct input_dev *dev, unsigned int type,
                 unsigned int code, int value)
{
        if (type == EV_SND && code == SND_BELL) {
                outb(value, BUTTON_BELL);
                return 0;
        }
        return -1;
}
```
This callback routine can be called from an interrupt or a BH (although that isn’t a rule), and thus must not sleep, and must not take too long to finish.
***
